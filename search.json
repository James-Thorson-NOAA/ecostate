[{"path":"/articles/model-description.html","id":"introducing-ecostate","dir":"Articles","previous_headings":"","what":"Introducing ecostate","title":"ecostate model description","text":"ecostate (Thorson et al. 2025) R package implements nonlinear state-space model representing equilibrium conditions Ecopath (Polovina 1984), biomass dynamics Ecosim (Walters, Christensen, Pauly 1997), age/stage-structured dynamics Ecosim version-2 (Walters et al. 2000). parameterization heavily inspired RPath (Lucey, Gaichas, Aydin 2020). However, also adds features available EwE Rpath including: Estimating equilibrium dynamical parameters simultaneously: ecostate uses maximum likelihood estimation identify values (standard errors) parameters representing ecosystem equilibrium (e.g., equilibrium biomass, production/consumption per biomass), ecosystem dynamics (e.g., ratio initial equilibrium biomass), measurement parameters (e.g., catchability coefficient); Process errors: ecostate can estimate errors biomass index catch measurements, well unexplained variation dynamics (termed â€œprocess errorsâ€). estimates variance process errors using hierarchical modelling techniques; Priors likelihood penalties: ecostate allows user specify Bayesian prior likelihood penalty parameters, rather fixing priori. features ensure anyone running ecostate can rapidly update model using new data ecosystem assumptions. Results can exactly reproduced, allowing model performance explored via simulation modelling.","code":""},{"path":"/articles/model-description.html","id":"state-space-mass-balance-modelling","dir":"Articles","previous_headings":"","what":"State-space mass balance modelling","title":"ecostate model description","text":"model starts defining equilibrium biomass Î²â€¾s\\bar{\\beta}_s taxon sâˆˆ{1,2,...,S}s \\\\{1,2,...,S\\}, using ii jj refer taxa prey predator. Every taxon defined heterotroph (consumer), autotroph (producer), detritus pool, affects dynamics explained later. equilibrium depends upon prey production per biomass pip_i, proportion prey production explained model (termed â€œecotrophic efficiencyâ€) eie_i, diet proportion di,jd_{,j} predator jj prey ii, predator consumption per biomass wjw_j: $$ \\underbrace{\\bar{\\beta}_i}_{\\text{Equilibrium biomass prey}} \\times \\underbrace{p_i}_{\\text{Prey production per biomass}} \\times \\underbrace{e_i}_{\\text{Ecotrophic efficiency}} = \\\\ \\sum_{j=1}^S{\\left(   \\underbrace{d_{,j}}_{\\text{Proportion diet predator }j \\text{ prey }}   \\times \\underbrace{\\bar{\\beta}_j}_{\\text{Equilibrium biomass predator }j}   \\times \\underbrace{w_j}_{\\text{Predator consumption per biomass}} \\right)} $$ Autotroph detritus taxa jj consumption di,jd_{,j} taxa. can solve SÃ—SS \\times S matrix equilibrium consumption ð‚â€¾\\bar{\\mathbf{C}} : ð‚â€¾=ðƒâŠ™(ðŸ(ð›ƒâ€¾âŠ™ð°)T) \\bar{\\mathbf{C}} = \\mathbf{D \\odot ( 1 (\\bar{\\beta} \\odot w)}^T ) Given equilibrium values, define differential equation biomass dynamics integrate time calculate biomass times tâˆˆ{1,2,...,T}t \\\\{ 1, 2, ..., T \\}. parallel, also integrate catches Î·s(t)\\eta_s(t) time, resetting Î·s(t)=0\\eta_s(t)=0 beginning time-interval recording integrated catch end interval: ddtð›ƒ(t)=(ð (t)âŸGrowth rateâˆ’ð¦(t)âŸNatural mortality rateâˆ’ðŸ(t)âŸFishing mortality rate+ð›œ(t)âŸProcess error)âŠ™ð›ƒ(t)ddtð›ˆ(t)=ðŸ(t)âŠ™ð›ƒ(t) \\begin{gather} \\frac{\\text{d}}{\\text{d}t} \\mathbf{\\beta}(t) = &   \\left(   \\underbrace{\\mathbf{g}(t)}_{\\text{Growth rate}} -    \\underbrace{\\mathbf{m}(t)}_{\\text{Natural mortality rate}} -    \\underbrace{\\mathbf{f}(t)}_{\\text{Fishing mortality rate}} +    \\underbrace{\\mathbf{\\epsilon}(t)}_{\\text{Process error}}   \\right)  & \\odot \\mathbf{\\beta}(t) \\\\ \\frac{\\text{d}}{\\text{d}t} \\mathbf{\\eta}(t) = & \\mathbf{f}(t) & \\odot \\mathbf{\\beta}(t) \\end{gather} biomass growth rate gs(t)g_s(t) natural mortality rate ms(t)m_s(t) calculated predicted consumption ð‚(t)\\mathbf{C}(t) representing mass ci,j(t)c_{,j}(t) prey ii consumed predator jj, fishing mortality fs(t)f_s(t) estimated parameter informed catch data. Consumption ci,j(t)c_{,j}(t) varies around equilibrium consumption: ci,j(t)=câ€¾,j(t)âŸequilibrium consumption rateÃ—xi,jÎ²j(t)Î²â€¾jxi,jâˆ’1+Î²j(t)Î²â€¾jâŸpredator functional responseÃ—Î²i(t)Î²â€¾âŸprey functional response c_{,j}(t) = \\underbrace{\\bar{c}_{,j}(t)}_{\\text{equilibrium consumption rate}} \\times \\underbrace{\\frac{x_{,j}\\frac{\\beta_j(t)}{\\bar{\\beta}_j}}{x_{,j} - 1 + \\frac{\\beta_j(t)}{\\bar{\\beta}_j}}}_{\\text{predator functional response}} \\times \\underbrace{\\frac{\\beta_i(t)}{\\bar{\\beta}_i}}_{\\text{prey functional response}}  ð—\\mathbf{X} matrix predator-prey vulnerability parameters xi,jx_{,j}. Natural mortality calculated : ms(t)=âˆ‘j=1Scs,j(t)Î²s(t)âŸPredation rate+{ps(1âˆ’es)âŸResidual natural mortality rate s autotroph heterotrophÎ½sâŸDetritus loss rate s detritus m_s(t) = \\underbrace{\\frac{\\sum_{j=1}^S c_{s,j}(t)}{\\beta_s(t)}}_{\\text{Predation rate}} +  \\begin{cases}   \\underbrace{p_s(1-e_s)}_{\\text{Residual natural mortality rate}} & \\text{ } s \\text{ autotroph heterotroph} \\\\   \\underbrace{\\nu_s}_{\\text{Detritus loss rate}} & {\\text{ } s \\text{ detritus}} \\end{cases}  residual natural mortality ps(1âˆ’es)p_s(1-e_s) accounts predation unmodeled taxa, senescence disease. residual mortality rate defined differently detritus taxa, detritus loss rate Î½s\\nu_s defined ensure net detritus accumulation matches net consumption plus export equilibrium: Î²â€¾sÎ½sâŸEquil. detritus loss=âˆ‘=1Sâˆ‘j=1SÎ¼jcâ€¾,j+âˆ‘j=1SÎ²â€¾jps(1âˆ’es)âŸEquil. detritus accumulationâˆ’âˆ‘j=1Scâ€¾s,jâŸEquil. detritus consumption \\underbrace{\\bar{\\beta}_s \\nu_s}_{\\text{Equil. detritus loss}} = \\underbrace{\\sum_{=1}^S \\sum_{j=1}^S \\mu_j \\bar{c}_{,j} + \\sum_{j=1}^S \\bar{\\beta}_j p_s (1-e_s)}_{\\text{Equil. detritus accumulation}} - \\underbrace{\\sum_{j=1}^S \\bar{c}_{s,j}}_{\\text{Equil. detritus consumption}}  Î¼j\\mu_j proportion consumption assimilated predator jj âˆ‘=1Sâˆ‘j=1SÎ¼jcâ€¾,j\\sum_{=1}^S \\sum_{j=1}^S \\mu_j \\bar{c}_{,j} flows detritus via unassimilated consumption. Similarly, pj(1âˆ’ej)p_j(1-e_j) unexplained mortality assume flows consumption total âˆ‘j=1SÎ²â€¾jps(1âˆ’es)\\sum_{j=1}^S \\bar{\\beta}_j p_s (1-e_s). Biomass growth rate gs(t)g_s(t) also calculated consumption: gs(t)={pswsÃ—âˆ‘=1Sci,s(t)Î²s(t) s heterotrophpsÎ²â€¾sÎ²s(t)Ã—xs,sÎ²s(t)Î²â€¾sxs,sâˆ’1+Î²s(t)Î²â€¾s x autotrophâˆ‘=1Sâˆ‘j=1SÎ¼jci,j(t)+âˆ‘j=1SÎ²j(t)pj(1âˆ’ej)Î²s(t) s detritus g_s(t) = \\begin{cases} \\frac{p_s}{w_s} \\times \\frac{\\sum_{=1}^S c_{,s}(t)}{\\beta_s(t)} & \\text{ } s \\text{ heterotroph} \\\\ \\frac{p_s \\bar{\\beta}_s}{\\beta_s(t)} \\times \\frac{x_{s,s}\\frac{\\beta_s(t)}{\\bar{\\beta}_s}}{x_{s,s} - 1 + \\frac{\\beta_s(t)}{\\bar{\\beta}_s}} & \\text{ } x \\text{ autotroph} \\\\ \\frac{\\sum_{=1}^S \\sum_{j=1}^S \\mu_j c_{,j}(t) + \\sum_{j=1}^S \\beta_j(t)p_j(1-e_j)}{\\beta_s(t)} & \\text{ } s \\text{ detritus}  \\end{cases}  expression states : Heterotrophs: growth rate heterotrophs consumption per biomass times ratio production consumption per biomass; Autotrophs: autotroph growth rate calculated production constant adjusted Type-2 functional response using vulnerability xs,sx_{s,s}; Detritus: detritus growth rate total detritus gain per detritus biomass.","code":""},{"path":[]},{"path":"/articles/model_of_intermediate_complexity.html","id":"eastern-bering-sea","dir":"Articles","previous_headings":"","what":"Eastern Bering Sea","title":"Model of Intermediate Complexity","text":"first load Survey, Catch, PB, QB values, define biological inputs: fit function call. slow: can plot estimated foodweb:  Runtime vignette: 1.71 mins","code":"# load data data(eastern_bering_sea)  # Reformat inputs years = 1982:2021 # Catch only goes through 2021, and starting pre-data in 1982 doesn't play well with fit_B0 taxa = c( \"Pollock\", \"Cod\", \"Arrowtooth\", \"Copepod\", \"Other_zoop\", \"Chloro\", \"NFS\", \"Krill\", \"Benthic_invert\", \"Benthos\", \"Detritus\" )  # Define types type_i = sapply( taxa, FUN=switch, \"Detritus\" = \"detritus\",                                    \"Chloro\" = \"auto\",                                    \"hetero\" )  # Starting values U_i = EE_i = B_i = array( NA, dim=length(taxa),                      dimnames=list(names(eastern_bering_sea$P_over_B))) B_i[c(\"Cod\", \"Arrowtooth\", \"NFS\")] = c(1, 0.5, 0.02) EE_i[] = 1 U_i[] = 0.2  # Define default vulnerability, except for primary producers X_ij = array( 2, dim=c(length(taxa),length(taxa)) ) dimnames(X_ij) = list(names(B_i),names(B_i)) X_ij[,'Chloro'] = 91 # Define parameters to estimate fit_Q = c(\"Pollock\", \"Copepod\", \"Chloro\", \"Other_zoop\", \"Krill\") fit_B0 = c(\"Pollock\", \"Cod\", \"Arrowtooth\", \"NFS\") fit_B = c(\"Cod\", \"Arrowtooth\", \"NFS\")    # Define process errors to estimate # Only estimating Pollock to speed up demonstration fit_eps = \"Pollock\"  # Which taxa to include taxa_to_include = c( \"NFS\", \"Pollock\", \"Copepod\", \"Chloro\", \"Krill\" ) # To run full model use: # taxa_to_include = taxa  # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE) }  # Run model out = ecostate( taxa = taxa_to_include,                 years = years,                 catch = eastern_bering_sea$Catch,                 biomass = eastern_bering_sea$Survey,                 PB = eastern_bering_sea$P_over_B,                 QB = eastern_bering_sea$Q_over_B,                 DC = eastern_bering_sea$Diet_proportions,                 B = B_i,                 EE = EE_i,                 U = U_i,                 type = type_i,                 X = X_ij,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( n_steps = 20, # using 15 by default                                             start_tau = 0.01,                                             tmbad.sparse_hessian_compress = 0 ))  # print output out #> Dynamics integrated using  ABM  with  20  time-steps #> Run time: Time difference of 1.675092 mins #> Negative log-likelihood: 111.8524 #>  #> EcoSim parameters: #>           type        QB          PB          B EE   U #> NFS     hetero 57.763550  0.09429851 0.01609925  0 0.2 #> Pollock hetero  4.225892  0.82452074 3.26652224  1 0.2 #> Copepod hetero 27.740000  6.00000000 1.85225167  1 0.2 #> Chloro    auto        NA 99.40685006 0.63388263  1 0.2 #> Krill   hetero 15.640000  5.48000000 1.05351582  1 0.2 #>  #> EcoSim diet matrix: #>          Predator #> Prey      NFS   Pollock Copepod Chloro     Krill #>   NFS       0 0.0000000       0      0 0.0000000 #>   Pollock   1 0.1277434       0      0 0.0000000 #>   Copepod   0 0.4540243       0      0 0.2941176 #>   Chloro    0 0.0000000       1      0 0.7058824 #>   Krill     0 0.4182324       0      0 0.0000000 #>  #> EcoSim vulnerability matrix: #>         NFS Pollock Copepod Chloro Krill #> NFS       2       2       2     91     2 #> Pollock   2       2       2     91     2 #> Copepod   2       2       2     91     2 #> Chloro    2       2       2     91     2 #> Krill     2       2       2     91     2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> delta_i  -0.9107485 0.07412192 #> delta_i  -0.9712690 0.10263244 #> logB_i   -4.1289824 0.05667705 #> logtau_i -1.1467111 0.14112593 #> logq_i    0.9289014 0.05572851 #> logq_i    1.0002721 0.06744515 #> logq_i    2.6850118 0.05908211 #> logq_i    2.3987716 0.07547528 #> Maximum gradient component: 0.0001222244 # Plot foodweb at equilibrium # using pelagic producers as x-axis and trophic level as y-axis plot_foodweb( out$rep$out_initial$Qe_ij,                 xtracer_i = ifelse(taxa_to_include==\"Krill\",1,0),               B_i = out$rep$out_initial$B_i,               type_i = type_i[taxa_to_include] ) #> Warning: Removed 4 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"/articles/not_on_cran/simulation.html","id":"simulation-demonstration","dir":"Articles > Not_on_cran","previous_headings":"","what":"Simulation demonstration","title":"Demonstrating EcoState via simulation","text":"W begin specifying parameters 5-species ecosystem: can simulate data using functions mass-balance simulating dynamics used EcoState parameter estimation:","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Name taxa (optional, for illustration) taxa = c(\"Consumer_1\", \"Consumer_2\", \"Predator_1\", \"Predator_2\", \"Producer\", \"Detritus\") n_species = length(taxa)  # Type for each taxon type_i = c( \"hetero\", \"hetero\", \"hetero\", \"hetero\", \"auto\", \"detritus\" )  # Diet matrix DC_ij = matrix( c(   0,     0,     0.8,  0.4,  0,   0,   0,     0,     0.2,  0.6,  0,   0,   0,     0,     0,    0,    0,   0,   0,     0,     0,    0,    0,   0,   0.9,   0.3,   0,    0,    0,   0,   0.1,   0.7,   0,    0,    0,   0 ), byrow=TRUE, ncol=n_species)  # Reciprocal of mean age according to Polovina-1984 ~= M PB_i = c( 4, 1, 0.2, 0.1, 90, 0.5 )  # Consumption per biomass for heterotrophcs QB_i = c( 10, 4, 3, 1, NA, NA )  # Define ecotrophic efficiency or biomass for each taxon EE_i = c( 0.9, 0.9, NA, NA, 0.9, 0.9 ) B_i = c( NA, NA, 1, 1, NA, NA )  # Unassimulated food U_i = rep( 0.2, n_species )  # Vulnerability matrix X_ij = matrix( 2, nrow=n_species, ncol=n_species ) X_ij[,which(type_i==\"auto\")] = 91  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(type_i) = names(U_i) = names(B_i) = names(EE_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa) # Define Biomass for Taxon-Year combinations with survey data Biomass = cbind( expand.grid( \"Year\" = years,                            \"Taxon\" = taxa ),                \"Mass\" = 1 )  # Define catch for Taxon-Year combinations with a fishery Catch = subset( Biomass, Taxon %in% c(\"Predator_1\",\"Predator_2\") )  # Build the model object out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = 0 ))  # Edit the parameters used parlist = out$obj$env$parList() # Fishing mortality for Predator_1 parlist$logF_ti[,3] = log( 0.2 * seq(0, 1, len=n_years) ) # Fishing mortality for Predator_2 parlist$logF_ti[,4] = log( 0.1 * seq(0, 1, len=n_years) )  # print output to terminal sim = out$simulator( parlist = parlist )"},{"path":"/articles/not_on_cran/simulation.html","id":"comparison-with-rpath","dir":"Articles > Not_on_cran","previous_headings":"","what":"Comparison with Rpath","title":"Demonstrating EcoState via simulation","text":"first compare functions used EcoState existing implementations model. One script-based implementation available R Rpath, therefore show syntax model-output comparison. comparison, first load Rpath reformat inputs format expects calculate mass-balance: can simulate forward time using Rpath:","code":"# Rpath needs types in ascending order (EcoState doesn't care) types  <- sapply( c(type_i,\"fishery\"), FUN=switch,                    \"hetero\"==0, \"auto\"=1, \"detritus\"=2, \"fishery\"=3 ) groups <- c( taxa, \"fishery\" ) stgroups = rep(NA, length(groups) ) REco.params <- create.rpath.params(group = groups, type = types, stgroup = stgroups)  # Fill in biomass #REco.params$model$Biomass = c( exp(Pars_full$logB_i), NA ) REco.params$model$Biomass = c( B_i, NA ) REco.params$model$EE = c( ifelse(type_i==\"detritus\",NA,EE_i), NA ) REco.params$model$PB = c( PB_i, NA ) REco.params$model$QB = c( QB_i, NA )  #Biomass accumulation and unassimilated consumption REco.params$model$BioAcc = c( rep(0,length(taxa)), NA ) REco.params$model$Unassim = c( ifelse(type_i==\"hetero\",0.2,0), NA )  #Detrital Fate REco.params$model$Detritus = c( ifelse(type_i==\"detritus\",0,1), 0 ) REco.params$model$fishery = c( rep(0,length(taxa)), NA ) REco.params$model$fishery.disc = c( rep(0,length(taxa)), NA )  # Diet for(j in 1:5) REco.params$diet[seq_along(taxa),j+1] = DC_ij[,j] REco.params$diet[seq_along(taxa),2] = DC_ij[,1]  # Balance using Ecopath equations check.rpath.params( REco.params) #> Rpath parameter file is functional. REco <- rpath(REco.params, eco.name = 'R Ecosystem') # Create simulation object REco.sim <- rsim.scenario(REco, REco.params, years = 1:40)  # REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_1', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.2 ) REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_2', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.1 )  # Match vulnerability for self-limitation in Producers REco.sim$params$VV[which(REco.sim$params$PreyFrom==0 & REco.sim$params$PreyTo==5)] = 91  #  REco.run1 <- rsim.run(REco.sim, method = 'RK4', years = 1:40)"},{"path":"/articles/not_on_cran/simulation.html","id":"simulate-using-ecostate","dir":"Articles > Not_on_cran","previous_headings":"","what":"Simulate using Ecostate","title":"Demonstrating EcoState via simulation","text":"Comparing scenario forecasted Rpath simulated time-series, see two closely match. EcoState uses functions fitting, also closely matches Rpath.","code":"# Calculate annual simulated catch Year = rep( years, each=12) Bsim_ti = apply( REco.run1$out_Biomass[,-1], MARGIN=2, FUN=\\(x) tapply(x,INDEX=Year,FUN=mean) )  # par(mfrow=c(2,1), mar=c(3,3,1,1), mgp=c(2,0.5,0) ) matplot( x=years, y=Bsim_ti / outer(rep(1,n_years),Bsim_ti[1,]),          type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Rpath)\", xlab=\"Year\" ) Brel_ti = sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]) matplot( x=years, y=sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]),          type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Simulated)\", xlab=\"Year\" ) legend(\"bottomleft\", fill=rainbow(n_species), legend=taxa, ncol=2, bty=\"n\")"},{"path":"/articles/not_on_cran/simulation.html","id":"fitting-the-model-using-ecostate","dir":"Articles > Not_on_cran","previous_headings":"","what":"Fitting the model using EcoState","title":"Demonstrating EcoState via simulation","text":"next want show EcoState performs fitting simulated data. first rebuild model process errors, simulate new data plot compare previous simulation process errors:  reformat simulated biomass catch time-series long-form data frames fit ecostate Finally, can extract elements fitted model, plot easily using ggplot2 compare known (simulated) values. exercise shows EcoState can accurately estimate biomass trends:","code":"# Build the model object out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_eps = taxa,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = 0 ))  # Simulate new data #sigmaB_i = c(0.02, 0.02, 0.1, 0.1, 0.1, 0.1) # Taxa 1-2 crashes solver if sigmaB > 0.02 #sim = simulate_data()  # Edit the parameters used parlist = out$obj$env$parList() # Fishing mortality for Predator_1 parlist$logF_ti[,3] = log( 0.2 * seq(0, 1, len=n_years) ) # Fishing mortality for Predator_2 parlist$logF_ti[,4] = log( 0.1 * seq(0, 1, len=n_years) ) # standard deviation for process errors in biomass dynamics parlist$logtau_i = log(c(0.02, 0.02, 0.1, 0.1, 0.1, 0.1))  # print output to terminal sim = out$simulator( parlist = parlist )  # Unload simulated data Bobs_ti = sim$Bobs_ti Cobs_ti = sim$Cobs_ti B_ti = sim$B_ti  # Plot simulation with process errors matplot( x=years, y=B_ti / outer(rep(1,n_years),B_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (simulated)\", xlab=\"Year\" ) # reformat to longform data-frame Catch = na.omit( data.frame( expand.grid( \"Year\" = rownames(sim$Cobs_ti),                                           \"Taxon\" = colnames(sim$Cobs_ti)),                  \"Mass\"=as.vector(sim$Cobs_ti))) Biomass = data.frame( expand.grid( \"Year\" = rownames(sim$Bobs_ti),                                           \"Taxon\" = colnames(sim$Bobs_ti)),                  \"Mass\"=as.vector(sim$Bobs_ti))  # Settings: specify what parameters to estimate fit_eps = c(\"Producer\", \"Detritus\", \"Predator_1\", \"Predator_2\")   # process errors fit_Q = c()       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass  # Solving for EE and giving uninformed initial values for biomass fittedB_i = sim$Bobs_ti[1,] fittedEE_i = rep(NA, n_species) names(fittedB_i) = names(fittedEE_i) = taxa  # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE) }  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( # Much faster to turn off                                             tmbad.sparse_hessian_compress = 0,                                             # Faster to profile these                                             profile = c(\"logF_ti\",\"logB_i\"),                                             # More stable when starting low                                             start_tau = 0.001 ))  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 2.04871 mins #> Negative log-likelihood: -276.8183 #>  #> EcoSim parameters: #>                type QB   PB          B        EE   U #> Consumer_1   hetero 10  4.0  0.7861948 0.8787131 0.2 #> Consumer_2   hetero  4  1.0  1.3367890 0.8910455 0.2 #> Predator_1   hetero  3  0.2  0.9846327 0.0000000 0.2 #> Predator_2   hetero  1  0.1  1.0006005 0.0000000 0.2 #> Producer       auto NA 90.0  0.1037043 0.9299841 0.2 #> Detritus   detritus NA  0.5 10.0965041 0.8971826 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1          2          2          2          2       91        2 #>   Consumer_2          2          2          2          2       91        2 #>   Predator_1          2          2          2          2       91        2 #>   Predator_2          2          2          2          2       91        2 #>   Producer            2          2          2          2       91        2 #>   Detritus            2          2          2          2       91        2 #>  #> Estimates: sdreport(.) result #>           Estimate Std. Error #> logtau_i -2.438964  0.2090417 #> logtau_i -3.158383  0.3105397 #> logtau_i -1.547155  0.9708793 #> logtau_i -2.254995  0.2185956 #> Maximum gradient component: 1.650295e-05 # Extract estimated biomass Bhat_ti = out$derived$Est$B_ti Bse_ti = out$derived$SE$B_ti  # Reformat to long-form data frame for ggplot results = expand.grid( \"Year\" = years, \"Taxon\" = taxa ) results = cbind( results,                   \"True\" = as.vector(B_ti),                  \"Est\" = as.vector(Bhat_ti),                  \"SE\" = as.vector(Bse_ti) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True) ) +    facet_wrap( vars(Taxon), scale=\"free\" ) +   geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-SE, ymax=Est+SE), alpha=0.2)"},{"path":"/articles/not_on_cran/simulation.html","id":"advanced-estimating-vulnerability-parameters","dir":"Articles > Not_on_cran","previous_headings":"","what":"Advanced: estimating vulnerability parameters","title":"Demonstrating EcoState via simulation","text":"can also explore estimating additional parameters. , explore estimating vulnerability: Runtime vignette: 4.27 mins","code":"# Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE)   # Prior on vulnerability to stabilize model (single value mirrored below)   logp = logp + dnorm( p$Xprime_ij[1,1], mean=0, sd=1, log=TRUE ) }  # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( inverse_method = \"Standard\",                                             nlminb_loops = 0,                                             tmbad.sparse_hessian_compress = 0,                                             getsd = FALSE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.1 ))  # Change tmb_par tmb_par = out0$tmb_inputs$p   tmb_par$Xprime_ij[,which(type_i!=\"auto\")] = log(1.5 - 1) map = out0$tmb_inputs$map   map$Xprime_ij = array(NA, dim=dim(tmb_par$Xprime_ij))   map$Xprime_ij[,which(type_i!=\"auto\")] = 1   map$Xprime_ij = factor(map$Xprime_ij)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( inverse_method = \"Standard\",                                             nlminb_loops = 1,                                             tmbad.sparse_hessian_compress = 0,                                             getsd = TRUE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.001,                                             tmb_par = tmb_par,                                             map = map ))   # alpha is faster than epsilon #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 2.103908 mins #> Negative log-likelihood: -275.9045 #>  #> EcoSim parameters: #>                type QB   PB          B        EE   U #> Consumer_1   hetero 10  4.0  0.7861405 0.8797942 0.2 #> Consumer_2   hetero  4  1.0  1.3365146 0.8920989 0.2 #> Predator_1   hetero  3  0.2  0.9858493 0.0000000 0.2 #> Predator_2   hetero  1  0.1  1.0013227 0.0000000 0.2 #> Producer       auto NA 90.0  0.1035994 0.9308375 0.2 #> Detritus   detritus NA  0.5 10.0885570 0.8977263 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1   1.983361   1.983361   1.983361   1.983361       91 1.983361 #>   Consumer_2   1.983361   1.983361   1.983361   1.983361       91 1.983361 #>   Predator_1   1.983361   1.983361   1.983361   1.983361       91 1.983361 #>   Predator_2   1.983361   1.983361   1.983361   1.983361       91 1.983361 #>   Producer     1.983361   1.983361   1.983361   1.983361       91 1.983361 #>   Detritus     1.983361   1.983361   1.983361   1.983361       91 1.983361 #>  #> Estimates: sdreport(.) result #>              Estimate Std. Error #> Xprime_ij -0.01677909  0.1636022 #> logtau_i  -2.43903330  0.2091244 #> logtau_i  -3.16204128  0.3134125 #> logtau_i  -1.54955378  0.9719704 #> logtau_i  -2.25520900  0.2186404 #> Maximum gradient component: 9.629189e-07"},{"path":"/articles/not_on_cran/surplus_production.html","id":"simulation-demonstration","dir":"Articles > Not_on_cran","previous_headings":"","what":"Simulation demonstration","title":"EcoState as surplus production model","text":"first simulate new data. , simulate Schaefer production model Gompertz effort dynamics:  set inputs EcoState Next, fit ecostate Finally can calculate function calculates annualized surplus production use function compare exact approximation uses first-order Euler approximation:  can also plot estimated true biomass","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Biology r = 0.2 #MSY = 100 K = 1000 sigmaB = 0.5 B0 = K * exp(sigmaB*rnorm(1)) prod_func = c(\"Schaefer\", \"Fox\")[2]  # Effort dynamics Bequil = 0.4 * K Brate = 0.2 sigmaE = 0.1 E0 = 0.01  # Survey q = 1 sigmaQ = 0.1  # Pbar_t = P_t = C_t = E_t = B_t = rep(NA, n_years) B_t[1] = B0 E_t[1] = E0  # for( t in 2:n_years ){   if(prod_func==\"Scaefer\") Pbar_t[t] = B_t[t-1] + r * B_t[t-1] * (1 - B_t[t-1]/K)   if(prod_func==\"Fox\") Pbar_t[t] = r * B_t[t-1] * log(K / B_t[t-1])   P_t[t] = Pbar_t[t] * exp(sigmaB*rnorm(1))   B_t[t] = B_t[t-1] + P_t[t]   E_t[t] = E_t[t-1] * (B_t[t-1]/Bequil)^Brate * exp(sigmaE*rnorm(1))   C_t[t] = B_t[t] * (1 - exp(-E_t[t]))   B_t[t] = B_t[t] - C_t[t] } Bobs_t = q * B_t * exp(sigmaQ * rnorm(n_years))  #  matplot( x=years, y=cbind(B_t,Bobs_t,C_t), type=\"l\", log=\"y\", lty=\"solid\") # Name taxa (optional, for illustration) taxa = \"target\" n_taxa = length(taxa)  # Ecopath-with-EcoSim parameters # Diet matrix DC_ij = array( 0, dim=c(1,1) ) PB_i = 0.1 QB_i = NA EE_i = 1 B_i = 1 U_i = 0.2 type_i = \"auto\" X_ij = array( 2, dim=c(1,1) )  # reformat to longform data-frame Catch = na.omit(data.frame( \"Mass\" = C_t, \"Year\" = years, \"Taxon\" = taxa )) Biomass = data.frame( \"Mass\" = Bobs_t, \"Year\" = years, \"Taxon\" = taxa ) # Settings: specify what parameters to estimate fit_eps = taxa   # process errors fit_Q = taxa       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass fit_PB = taxa     # Productivity _propto_ natural mortality  # Treat it as an autotroph (given there's no prey to consume) type = \"auto\"  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on productivity   logp = dnorm( p$logPB_i, mean=log(0.1), sd=0.5, log=TRUE )   # Prior on process-error log-SD to stabilize model   logp = logp + dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE )   # Prior on vulnerability to stabilize model   logp = logp + dnorm( p$Xprime_ij[1,1], mean=0, sd=1, log=TRUE ) }  # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 fit_PB = fit_PB,                 log_prior = log_prior,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = FALSE,                                             start_tau = 0.1 ) )  # Estimate logPB pars = out0$tmb_inputs$p map = out0$tmb_inputs$map map$Xprime_ij = factor(1)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 fit_PB = fit_PB,                 log_prior = log_prior,                 control = ecostate_control( map = map,                                             tmb_par = pars ) ) #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 4.54516 secs #> Negative log-likelihood: -74.51341 #>  #> EcoSim parameters: #>        type QB        PB        B EE   U #> target auto NA 0.1588959 1357.543  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     target #>   target      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey       target #>   target 1.357989 #>  #> Estimates: sdreport(.) result #>             Estimate Std. Error #> logB_i     7.2134320  0.3091545 #> logPB_i   -1.8395058  0.4064990 #> Xprime_ij -1.0272522  0.6851844 #> logtau_i  -3.0608084  0.4094129 #> logq_i    -0.3785607  0.3285576 #> Maximum gradient component: 0.000126564 # Define function to calculate annualized production prod_fun = function( biomass, Xprime, logPB, taxon, ecofit ){   p = ecofit$internal$parhat   n_taxa = length(ecofit$internal$taxa)   if(!missing(Xprime)) p$Xprime_ij[] = Xprime   if(!missing(logPB)) p$logPB_i[] = logPB   if(missing(taxon)) taxon = ecofit$internal$taxa[n_taxa]   p = add_equilibrium( p,                        scale_solver = ecofit$internal$control$scale_solver,                        noB_i = ifelse(is.na(p$logB_i),1,0),                        type_i = type_i )   p$logF_i = rep(log(0), n_taxa)   p$epsilon_i = rep(0, n_taxa)   p$nu_i = rep(0, n_taxa)   p$phi_g2 = rep(0, ecofit$internal$settings$n_g2)   State = c( ecofit$rep$out_initial$B_i, rep(0,n_taxa) )   State[match(taxon,ecofit$internal$taxa)] = biomass   #dBdt(Time=0, State=State, Pars=p)   proj = abm3pc_sys(         f = dBdt,         a = 0,          b = 1,         n = ecofit$internal$control$n_steps,         Pars = p,         type_i = type_i,         n_species = n_taxa,         F_type = \"integrated\",         y0 = State )   biomass1 = rev( proj$y[,match(taxon,ecofit$internal$taxa)] )[1]   return( biomass1 - biomass ) } # Calculate predicted and true curves x = seq(0, 2*K, length=1000)[-1] if(prod_func==\"Scaefer\") y = r * x * (1 - x/K) if(prod_func==\"Fox\") y = r * x * log(K/x) yhat = sapply( x, FUN=prod_fun, ecofit=out,                Xprime = out$internal$parhat$Xprime_ij,                 logPB = out$internal$parhat$logPB_i )  # Solve for Bmsy / B0 in production function dBdt_approx = function(b, x, p){   # dBdt for single autotroph (not annualized)   dBdt_expr = expression(b * p * (1-b) / (x - 1 + b))   # Solve for d/db dBdt = 0 as min_b((d/db dBdt)^2)   #eval( D(dBdt,\"b\") )^2   # OR:  -dBdt   eval(dBdt_expr) } phi1 = optimize( dBdt_approx, lower=0.01, upper=0.99, maximum=TRUE,                 x = 1+exp(out$internal$parhat[['Xprime_ij']][1,1]),                  p = exp(out$internal$parhat[['logPB_i']]) )$maximum # Empirical phi2 = x[which.max(yhat)] / 1000  # msy1 = exp(out$internal$parhat$logB_i) * dBdt_approx(phi1,                  x = 1+exp(out$internal$parhat[['Xprime_ij']][1,1]),                  p = exp(out$internal$parhat[['logPB_i']]) ) # msy2 = yhat[which.max(yhat)] #  true_msy = y[which.max(y)]  # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) lines( x=x, y=yhat, lwd=3, col=\"red\" )    # *exp(out$internal$parhat$logq_i) # Extract estimated biomass Bhat_t = out$derived$Est$B_ti Bse_t = out$derived$SE$B_ti  # Reformat to long-form data frame for ggplot results = cbind( \"Year\" = years,                  \"True\" = as.vector(B_t),                  \"Obs\" = as.vector(Bobs_t),                  \"Est\" = as.vector(Bhat_t),                  \"SE\" = as.vector(Bse_t) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True), colour=\"red\" ) +    geom_line( aes(x=as.numeric(Year), y=Obs) ) +    geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-1.96*SE, ymax=Est+1.96*SE), alpha=0.2)"},{"path":"/articles/not_on_cran/surplus_production.html","id":"bivariate-production-model","dir":"Articles > Not_on_cran","previous_headings":"","what":"Bivariate production model","title":"EcoState as surplus production model","text":"Similarly, fit two-species production model data: can calculate visualize changes production function:","code":"# Inputs taxa = c( \"prey\", \"target\" ) n_taxa = length(taxa) PB_i = c( 5, 0.1 ) QB_i = c( NA, 0.5 ) DC_ij = matrix( c(0,0,1,0), nrow=2 ) X_ij = matrix( 2, nrow=2, ncol=2 ) U_i = c( 0.2, 0.2 ) type = c( \"auto\", \"hetero\" ) EE_i = c( 1, NA )  B_i = c( NA, 1 )  # Settings: specify what parameters to estimate fit_eps = \"target\"   # process errors fit_Q = \"target\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"target\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ) }  # Run model out_bivar = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control() )  # print output to terminal out_bivar #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 22.38911 secs #> Negative log-likelihood: -75.16433 #>  #> EcoSim parameters: #>          type  QB  PB         B EE   U #> prey     auto  NA 5.0  81.99584  1 0.2 #> target hetero 0.5 0.1 819.95841  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey target #>   prey      0      1 #>   target    0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey target #>   prey      2      2 #>   target    2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.7092536  0.0935837 #> logtau_i -2.6240934  0.2387366 #> logq_i    0.1161167  0.1428179 #> Maximum gradient component: 1.10751e-05 # Calculate annualized production function yhat_bivar = sapply( x, FUN=prod_fun, ecofit=out_bivar, taxon=\"target\",                Xprime = out_bivar$internal$parhat$Xprime_ij,                 logPB = out_bivar$internal$parhat$logPB_i )  # Empirical phi_bivar = x[which.max(yhat_bivar)] / 1000  msy_bivar = yhat_bivar[which.max(yhat_bivar)]   # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) matplot( x=x, y=cbind(yhat,yhat_bivar), lwd=3, col=c(\"red\",\"blue\"),           type=\"l\", add=TRUE )   legend( \"topright\", fill=c(\"black\",\"red\",\"blue\"),          legend=c(\"True\",\"1-species\",\"2-species\"), bty=\"n\")"},{"path":"/articles/not_on_cran/surplus_production.html","id":"age-structured-model","dir":"Articles > Not_on_cran","previous_headings":"","what":"Age-structured model","title":"EcoState as surplus production model","text":"Additionally, fit model also tracking abundance, average weight, consumption age target species. including single stanza. allows us extract time-series average age average weight.  age-structured production model, mean age decreases increased fishing, mean weight increases due compensatory growth ratio forage predator increases.","code":"# Inputs taxa = c( \"prey\", \"target\" ) n_taxa = length(taxa) PB_i = c( 5, 0.1 ) QB_i = c( NA, 0.5 ) DC_ij = matrix( c(0,0,1,0), nrow=2 ) X_ij = matrix( 2, nrow=2, ncol=2 ) U_i = c( 0.2, 0.2 ) type = c( \"auto\", \"hetero\" ) EE_i = c( 1, NA )  B_i = c( NA, 1 )  # Settings: specify what parameters to estimate fit_eps = \"target\"   # process errors fit_Q = \"target\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"target\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ) }  # Run model out_stanzas = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control(),                 log_prior = log_prior,                 settings = stanza_settings( taxa = taxa,                                             stanza_groups = c(\"target\"=\"age_structured\"),                                             K = c(\"age_structured\" = 0.1),                                             Wmat = c(\"age_structured\" = (2/3)^3),                                             d = c(\"age_structured\" = 2/3),                                             Amax = c(\"target\" = 30),                                             SpawnX = c(\"age_structured\" = 2)                                            ))  # print output to terminal out_stanzas #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 25.97284 secs #> Negative log-likelihood: -71.35349 #>  #> EcoSim parameters: #>          type  QB  PB         B EE   U #> prey     auto  NA 5.0  104.2852  1 0.2 #> target hetero 0.5 0.1 1042.8523  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey target #>   prey      0      1 #>   target    0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey target #>   prey      2      2 #>   target    2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.9497148 0.02793407 #> logtau_i -3.1538949 0.50332833 #> logq_i   -0.1443941 0.04695328 #> Maximum gradient component: 0.0002864114  # meanage_t = meanweight_t = rep(NA, length(years)) for(t in seq_along(years)){   meanage_t[t] = weighted.mean( x = 1:30,                                 w = exp(out_stanzas$rep$Y_tzz_g2[[1]][t,,'log_NageS']) )   meanweight_t[t] = weighted.mean( x = out_stanzas$rep$Y_tzz_g2[[1]][t,,'WageS'],                                    w = exp(out_stanzas$rep$Y_tzz_g2[[1]][t,,'log_NageS']) ) } par( mfrow=c(2,1), mar=c(3,4,2,1) ) plot( x=years, y=meanage_t, lwd=2, type=\"l\", main=\"Mean age\" ) plot( x=years, y=meanweight_t, lwd=2, type=\"l\", main=\"Mean weight\" )"},{"path":"/articles/not_on_cran/surplus_production.html","id":"multi-stanza-age-structured-production-model","dir":"Articles > Not_on_cran","previous_headings":"","what":"Multi-stanza age-structured production model","title":"EcoState as surplus production model","text":"Finally, fit model three variables, representing forage species two age-structured â€œstanzasâ€ focal species. , specify identical diet varying bioenergetics size: model includes process-errors first-stage (eggs recruits, age-0 age-2) second stage (age-2 onward), although variance stage-1 collapses zero simulation replicate.","code":"# Inputs taxa = c( \"prey\", \"stage1\", \"stage2\" ) n_taxa = length(taxa) PB_i = c( 5, 1, 0.1 ) QB_i = c( NA, NA, 0.5 ) DC_ij = cbind( \"prey\"=c(0,0,0), \"stage1\"=c(1,0,0), \"stage2\"=c(1,0,0)  ) X_ij = matrix( 2, nrow=length(taxa), ncol=length(taxa) ) U_i = c( 0.2, 0.2, 0.2 ) type = c( \"auto\", \"hetero\", \"hetero\" ) EE_i = c( 1, NA, NA )  B_i = c( NA, NA, 1 )  # Settings: specify what parameters to estimate fit_eps = c(\"stage1\",\"stage2\")   # process errors fit_Q = \"stage2\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"stage2\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)  # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i[2:3], mean=log(0.2), sd=1, log=TRUE)) }  # Run model out_trivar = ecostate(    taxa = taxa,   years = years,   catch = data.frame(\"Mass\"=Catch[,1],\"Year\"=Catch[,2],\"Taxon\"=\"stage2\"),   biomass = data.frame(\"Mass\"=Biomass[,1],\"Year\"=Biomass[,2],\"Taxon\"=\"stage2\"),   PB = PB_i,   QB = QB_i,   DC = DC_ij,   B = B_i,   EE = EE_i,   X = X_ij,   type = type,   U = U_i,   fit_B = fit_B,   fit_Q = fit_Q,   fit_eps = fit_eps,   fit_B0 = fit_B0,   log_prior = log_prior,   control = ecostate_control(),   settings = stanza_settings(      taxa = taxa,     stanza_groups = c(\"stage1\"=\"age_structured\", \"stage2\"=\"age_structured\"),     K = c(\"age_structured\" = 0.1),     Wmat = c(\"age_structured\" = (2/3)^3),     d = c(\"age_structured\" = 2/3),     Amax = c(\"stage1\" = 2, \"stage2\" = 30),     SpawnX = c(\"age_structured\" = 2) ) ) #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = list(obj$gr, #> : NA/NaN function evaluation  # print output to terminal out_trivar #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 1.304584 mins #> Negative log-likelihood: -70.41958 #>  #> EcoSim parameters: #>          type       QB  PB            B EE   U #> prey     auto       NA 5.0  106.7457516  1 0.2 #> stage1 hetero 3.916939 1.0    0.8281451  0 0.2 #> stage2 hetero 0.500000 0.1 1060.9699286  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey stage1 stage2 #>   prey      0      1      1 #>   stage1    0      0      0 #>   stage2    0      0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey stage1 stage2 #>   prey      2      2      2 #>   stage1    2      2      2 #>   stage2    2      2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.9669388 0.08521457 #> logtau_i  0.3498846 0.37557231 #> logtau_i -3.1440545 0.50456842 #> logq_i   -0.1292594 0.09806604 #> Maximum gradient component: 1.808871e-09"},{"path":"/articles/not_on_cran/surplus_production.html","id":"comparison-with-other-models","dir":"Articles > Not_on_cran","previous_headings":"","what":"Comparison with other models","title":"EcoState as surplus production model","text":"can compare state-space production model continuous time (SPiCT):  Similarly, can compare Just Another Bayesian Biomass Assessment (JABBA):  Comparing two shows SPICT, JABBA, configurations EcoState errors estimating population scale, presumably due mis-specifying production function. expected, age-structured 2-species EcoState models result identical estimates, age-structured version also provides auxiliary information changes average age size. Runtime vignette: 2.67 mins","code":"# Format for SPiCT datalist = list(   obsC = C_t[-1],   timeC = years[-1],   obsI = Bobs_t,   timeI = years               )  # Fit and plot res <- fit.spict(datalist) plotspict.biomass(res) # Compile JABBA JAGS model and input object jbinput = build_jabba( catch = data.frame(Year=years, Total=C_t)[-1,],                        cpue = data.frame(Year=years, Index=Bobs_t)[-1,],                        se = data.frame(Year=years, Index=0.1)[-1,],                        assessment = \"target\",                        scenario = \"TestRun\",                        model.type = \"Schaefer\",                        sigma.est = FALSE,                        fixed.obsE = 0.1 ) #>  #> ><> Prepare JABBA input data <>< #>  #> ><> Assume Catch with error CV = 0.1 <>< #>  #> ><> Model type:Schaefer <>< #>  #> ><> Shape m =2 #>  #> ><> K prior mean =888.164844109276and CV =1(log.sd = 0.832554611157698) #>  #> ><> r prior mean =0.2and CV =0.532940350027788(log.sd = 0.5) #>  #> ><> Psi (B1/K) prior mean =0.9and CV =0.25withlnormdestribution #>  #>  #>  #> ><> ALWAYS ENSURE to adjust default settings to your specific stock <><  # Fit JABBA (here mostly default value - careful) bet1 = fit_jabba(jbinput, quickmcmc=TRUE) #> module glm loaded #> Compiling model graph #>    Resolving undeclared variables #>    Allocating nodes #> Graph information: #>    Observed stochastic nodes: 120 #>    Unobserved stochastic nodes: 124 #>    Total graph size: 2169 #>  #> Initializing model #>  #> ><> Produce results output of Schaefer model for target TestRun <>< #>  #>  #> ><> Scenario TestRun_Schaefer completed in 0 min and 16 sec <><  # Make individual plots jbplot_cpuefits(bet1) #>  #> ><> jbplot_cpue() - fits to CPUE <>< # Compare estimates knitr::kable(rbind(   \"True\" = c(\"q\" = q, \"K\"=K, \"MSY\"=true_msy),   \"EcoState 1-species\" = c(exp(out$opt$par[c('logq_i','logB_i')]),msy2),   \"EcoState 2-species\" = c(exp(out_bivar$opt$par[c('logq_i','logB_i')]),msy_bivar),   \"EcoState age-structured\" = c(exp(out_stanzas$opt$par[c('logq_i','logB_i')]),NA),   \"EcoState multi-stanza\" = c(exp(out_trivar$opt$par[c('logq_i','logB_i')]),NA),   \"SPiCT\" = c(res$value[c('q','K','MSY')]),   \"JABBA\" = c(bet1$pars[c('q','K'),'Median'],bet1$estimates['MSY','mu']) ), digits=3)"},{"path":"/articles/too_slow/age_structured_interactions.html","id":"gulf-of-alaska","dir":"Articles > Too_slow","previous_headings":"","what":"Gulf of Alaska","title":"Age-structured and bottom-up interactions","text":"first load example data included package: define various inputs used model.","code":"# Load, inspect, and attach data data(gulf_of_alaska) names(gulf_of_alaska) #>  [1] \"years\"            \"taxa\"             \"type\"             \"B\"                #>  [5] \"P_over_B\"         \"Q_over_B\"         \"EE\"               \"Diet_proportions\" #>  [9] \"stanza_groups\"    \"Amax\"             \"K\"                \"d\"                #> [13] \"Amat\"             \"Wmat\"             \"Leading\"          \"Wmatslope\"        #> [17] \"catch_data\"       \"biomass_data\"     \"agecomp_data\" attach(gulf_of_alaska)"},{"path":"/articles/too_slow/age_structured_interactions.html","id":"defining-inputs","dir":"Articles > Too_slow","previous_headings":"Gulf of Alaska","what":"Defining inputs","title":"Age-structured and bottom-up interactions","text":"specify discretization used integrating differential equations biomass dynamics, difference equations age-structured populations: also specify default values vulnerability unassimilated food: specify parameters estimate: Finally, define priors using function applied parameters","code":"# Biomass-dynamics steps n_step = 50  # Age-structured dynamics steps STEPS_PER_YEAR = 24 # Constant expected recruitment (matching assessment models) # So h = 0.999 and back-calculate SpawnX SpawnX = c( \"Walleye pollock\" = 4 / (5-1/0.999), \"Sablefish\" = 4 / (5-1/0.999) )  # Default vulnerability as fixed or starting values X = array( 2,             dim = rep(length(taxa),2),            dimnames = list(Prey=taxa,Predator=taxa) )  # Unassimilated food U = array( 0.2, dim=length(taxa), dimnames=list(taxa) ) # Estimate catchability coefficient for all surveys fit_Q = c( \"Walleye pollock adult\", \"Sablefish adult\",             \"Euphausiids\", \"Large copepods\" )  # Fit biomass-dynamics process errors for zooplankton fit_eps = c( \"Euphausiids\", \"Large copepods\" )   #  # Fit recruitment deviations for age-structured populations fit_phi = c(\"Walleye pollock\", \"Sablefish\")  # Fit equilibrium biomass for age-structured populations # using fishery as depletion experiment to identify scale fit_B = c(\"Walleye pollock juv\", \"Sablefish adult\")  # Fit PB with a prior fit_PB = c( \"Walleye pollock adult\", \"Sablefish adult\" )  # Fit vulnerability for adult age-structured populations with a prior fit_X = c(\"Walleye pollock adult\", \"Sablefish adult\") log_prior = list(      # Normal(0,0.5) prior on diag(Xprime_ij), where X = exp(Xprime) + 1   diag(Xprime_ij) ~ dnorm(mean = 0, sd = 0.5),      # Normal prior on log(q) for adult pollock, matching stock assessment   logq_i['Walleye pollock adult'] ~ dnorm(mean = log(0.85), sd = 0.1),      # Tight normal prior on log(PB) for sablefish, matching assessment M value   logPB_i[\"Sablefish adult\"] ~ dnorm(mean = log(0.1), sd = 0.1),      # Tight normal prior on log(PB) for pollock, matching assessment M value   logPB_i['Walleye pollock adult'] ~ dnorm(mean = log(0.3), sd = 0.1)    )"},{"path":"/articles/too_slow/age_structured_interactions.html","id":"building-and-running-the-model","dir":"Articles > Too_slow","previous_headings":"Gulf of Alaska","what":"Building and running the model","title":"Age-structured and bottom-up interactions","text":"Finally, build inputs without running model modify starting fixed values needed: Finally, re-build run model using manual updates can visualize estimated food web  can also visualize fits age-composition data. , first make helper function extract plot fitted estimated values show sablefish:  pollock  Fits confirm model can track cohorts age-structured dynamics Runtime vignette: 8.87 mins","code":"out = ecostate(   taxa = taxa,   years = years,   catch = catch_data,   biomass = biomass_data,   agecomp = agecomp_data,   PB = P_over_B,   QB = Q_over_B,   DC = Diet_proportions,   B = B,   EE = EE,   X = X,   type = type,   U = U,   fit_B = fit_B,   fit_Q = fit_Q,   fit_PB = fit_PB,   fit_eps = fit_eps,   log_prior = log_prior,   control = ecostate_control(      n_steps = n_step,        profile = NULL, # Penalized likelihood so use empty set     random = NULL, # Penalized likelihood so use empty set     nlminb_loops = 0,     getsd = FALSE ),   settings = stanza_settings(     taxa = taxa,     stanza_groups = stanza_groups,     K = K,     Wmat = Wmat,     Amat = Amat,     d = d,     Amax = Amax,     SpawnX = SpawnX,     fit_phi = fit_phi,     STEPS_PER_YEAR = STEPS_PER_YEAR,     comp_weight = \"multinom\",     Leading = Leading,     Wmatslope = Wmatslope) ) map = out$tmb_inputs$map tmb_par = out$obj$env$parList()  # Estimate vulnerability for adult fish with prior map$Xprime_ij = factor( ifelse(taxa %in% fit_X, seq_along(taxa), NA)[col(array(dim=rep(length(taxa),2)))] )  # Penalized likelihood:  Fixed SD for process errors = 1 map$logtau_i = factor(rep(NA,length(map$logtau_i))) tmb_par$logtau_i = ifelse( is.na(tmb_par$logtau_i), NA, log(1) )   # Penalized likelihood:  Fixed SD for recruitment deviations = 1 map$logpsi_g2 = factor(rep(NA,length(map$logpsi_g2))) tmb_par$logpsi_g2 = ifelse( is.na(tmb_par$logpsi_g2), NA, log(1) ) out = ecostate(   taxa = taxa,   years = years,   catch = catch_data,   biomass = biomass_data,   agecomp = agecomp_data,   PB = P_over_B,   QB = Q_over_B,   DC = Diet_proportions,   B = B,   EE = EE,   X = X,   type = type,   U = U,   fit_B = fit_B,   fit_Q = fit_Q,   fit_PB = fit_PB,   fit_eps = fit_eps,   log_prior = log_prior,   control = ecostate_control(      n_steps = n_step,        profile = NULL, # Penalized likelihood so use empty set     random = NULL, # Penalized likelihood so use empty set     derived_quantities = c(), # Turn off for speed     map = map,       # Pass map back in     tmb_par = tmb_par,  # Pass parameters back in     getsd = FALSE ),   settings = stanza_settings(     taxa = taxa,     stanza_groups = stanza_groups,     K = K,     Wmat = Wmat,     Amat = Amat,     d = d,     Amax = Amax,     SpawnX = SpawnX,     fit_phi = fit_phi,     STEPS_PER_YEAR = STEPS_PER_YEAR,     comp_weight = \"multinom\",     Leading = Leading,     Wmatslope = Wmatslope) ) library(ggplot2) plot_foodweb(    out$rep$out_initial$Qe_ij,   xtracer_i = ifelse(taxa %in% c(\"Small phytoplankton\",\"Large phytoplankton\"),1,0),   B_i = out$rep$out_initial$B_i,   type_i = type ) #> Warning: Removed 14 rows containing missing values or values outside the scale range #> (`geom_point()`). do_plot = function( stanzagroup_index ){   # Extract matrices and make into proportion at age   Obs = out$internal$Nobs_ta_g2[[stanzagroup_index]]   Hat = out$rep$Nexp_ta_g2[[stanzagroup_index]]   Obs = sweep( Obs, MARGIN=1, STATS=rowSums(Obs,na.rm=TRUE), FUN=\"/\" )   Hat = sweep( Hat, MARGIN=1, STATS=rowSums(Hat,na.rm=TRUE), FUN=\"/\" )      # Make long-form data frame   DF = expand.grid(      \"Year\" = rownames(Obs),     \"Age\" = colnames(Obs)   )   DF$Age = as.numeric(DF$Age)   DF$Obs = as.numeric(Obs)   DF$Hat = as.numeric(Hat)      #   ggplot(DF) +     geom_point( aes(x=Age, y=Obs) ) +     facet_wrap( vars(Year), ncol=5, shrink=FALSE ) +    # , labeller=hospital_labeller     geom_line( aes(x=Age, y=Hat) ) +        # , linetype=\"dotted\"     scale_y_continuous(name = \"Proportion at age\") +     theme_classic() } do_plot(1) #> Warning: Removed 27 rows containing missing values or values outside the scale range #> (`geom_point()`). do_plot(2)"},{"path":"/articles/too_slow/whole_of_ecosystem.html","id":"eastern-bering-sea","dir":"Articles > Too_slow","previous_headings":"","what":"Eastern Bering Sea","title":"Whole of ecosystem model","text":"first load various inputs used Rpath: also load time-series surveys catches used MICE model demonstration: reformat various Rpath inputs. particular, eliminate pelagic detritus pool (EcoState currently allow one detritus functional group), add benthic_detritus Ecopath inputs (Ecopath solves equilibrium values detritus jointly groups): specify parameters estimate: Finally, build inputs without running model, modify TMB map manually, estimate parameters can compare equilibrium biomass packages. identical many taxa () specify values biomass many taxa, also differ arrowtooth cod estimating equilibrium biomass two taxa: Runtime vignette: 25.27 mins","code":"data( whitehouse_2021 ) Ecopath = whitehouse_2021$Ecopath Diet = whitehouse_2021$Diet stanzas = whitehouse_2021$stanzas stanza_groups = whitehouse_2021$stanza_groups data( eastern_bering_sea ) Catch = eastern_bering_sea$Catch catch = data.frame( \"Year\"=Catch$Year, \"Mass\"=Catch$Mass, \"Taxon\"=Catch$Taxon ) catch$Taxon = sapply( catch$Taxon, FUN=switch, \"Arrowtooth\" = \"Arrowtooth flounder adult\",                                                \"Cod\" = \"Pacific cod adult\",                                                \"Pollock\" = \"Walleye pollock adult\" )  # Fish = eastern_bering_sea$Survey biomass = data.frame(   \"Mass\" = Fish$Mass,   \"Year\" = Fish$Year,   \"Taxon\" = sapply( Fish$Taxon, FUN=switch, \"Arrowtooth\" = \"Arrowtooth flounder adult\",                                               \"Cod\" = \"Pacific cod adult\",                                               \"Pollock\" = \"Walleye pollock adult\",                                               NA) ) biomass = na.omit(biomass) # which_ecopath = setdiff(1:nrow(Ecopath), 66) taxa = c( Ecopath[which_ecopath,'Functional.group'], \"benthic_detritus\" ) type = sapply( taxa, FUN = switch,                       \"benthic_detritus\" = \"detritus\",                       \"Large phytoplankton\" = \"auto\",                       \"Small phytoplankton\" = \"auto\",                       \"hetero\" ) PB = c( Ecopath[which_ecopath,'P.B'], 0.5 ) QB = c( Ecopath[which_ecopath,'Q.B'], NA ) B = c( Ecopath[which_ecopath,'Biomass'], NA ) EE = c( Ecopath[which_ecopath,'EE'], 0.5 ) U = c( rep(0.2,length(which_ecopath)), 0 )  # Modify EE EE = ifelse( taxa %in% c(\"benthic_detritus\",\"Walleye pollock adult\"), EE, NA )  #  which_cols = which_ecopath + 1 which_rows = c( which_ecopath, 72 ) DC = cbind( Diet[which_rows, which_cols], \"benthic_detritus\"=0 ) DC = ifelse( is.na(DC), 0, as.matrix(DC) ) X = array(2, dim=rep(length(taxa),2) )  # stgroups = stanza_groups[,'StanzaGroup'][stanzas[,'StGroupNum']] Amax = ceiling((stanzas[,'Last']+1) / 12)  # K = stanza_groups[,'VBGF_Ksp'] d = stanza_groups[,'VBGF_d'] Wmat = stanza_groups[,'Wmat'] SpawnX = rep(2, length(K))  # Add names names(PB) = names(QB) = names(B) = names(EE) = names(U) = names(type) = taxa dimnames(DC) = dimnames(X) = list( taxa, taxa ) names(Amax) = names(stgroups) = taxa[stanzas[,'GroupNum']] names(K) = names(d) = names(Wmat) = names(SpawnX) = unique(stgroups)  # Eliminate juvenile values which_juv = stanzas[which(!stanzas[,'Leading']),'GroupNum'] QB[which_juv] = B[which_juv] = NA # Fit catchability coefficient for adult pollock fit_Q = c( \"Walleye pollock adult\" )  # fit equilibrium biomass for adult arrowtooth and cod fit_B = c( \"Arrowtooth flounder adult\", \"Pacific cod adult\" ) run = function( map, nlminb_loops, getsd ){   out = ecostate(     taxa = taxa,     years = 1981:2020,     catch = catch,     biomass = biomass,     PB = PB,     QB = QB,     DC = DC,     B = B,     EE = EE,     X = X,     type = type,     U = U,     fit_B = fit_B,     fit_Q = fit_Q,     control = ecostate_control( nlminb_loops = nlminb_loops,                                 getsd = getsd,                                 n_steps = 30,                                 profile = NULL,                                 random = NULL,                                 map = map,                                 start_tau = 0.1 ),     settings = stanza_settings(       taxa = taxa,       stanza_groups = stgroups,       K = K,       Wmat = Wmat,       d = d,       Amax = Amax,       SpawnX = SpawnX,       STEPS_PER_YEAR = 12 )   ) } out0 = run( map = NULL,            nlminb_loops = 0,            getsd = FALSE ) map = out0$tmb_inputs$map   map$logtau_i = factor(rep(NA,length(map$logtau_i))) out = run( map = map,            nlminb_loops = 1,            getsd = TRUE ) # runtime out$run_time #> Time difference of 24.33986 mins  # Compile stuff Borig = c( Ecopath[which_ecopath,'Biomass'], NA ) Bhat = print_ecopars(out, silent=TRUE)[[1]][,'B'] df = data.frame( taxa,                   \"Whitehouse\" = Borig,                   \"EcoState\" = Bhat,                   \"Difference\" = Bhat - Borig ) knitr::kable( df, digits=3 )"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James T. Thorson. Author, maintainer. Maurice C. Goodman. Contractor.           Added improved interface priors, DSEM interface forcing functions covariates","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. Benefits Hierarchical Ecosystem Models: Demonstration Using EcoState, New State-Space Mass-Balance Model","code":"@Article{,   title = {The Benefits of Hierarchical Ecosystem Models: Demonstration Using EcoState, a New State-Space Mass-Balance Model},   journal = {Fish and Fisheries},   year = {2024},   doi = {10.1111/faf.12874},   url = {https://doi.org/10.1111/faf.12874},   author = {J. T. Thorson and K. Kristensen and K. Aydin and S. Gaichas and D. G. Kimmel and E. A. McHuron and J. N. Nielsen and H. Townsend and G. A. Whitehouse}, }"},{"path":"/index.html","id":"ecostate","dir":"","previous_headings":"","what":"State-Space Mass-Balance Model for Marine Ecosystems","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"Package ecostate fits state-space mass-balance model EcoState intended aquatic ecosystems, using mass-balance equations matching Ecopath dynamical equations matching Ecosim. Unlike Ecopath--Ecosim (EwE) package, ecostate fits biological parameters (e.g., equilibrium biomass predator-prey vulnerability) measurement parameters (e.g., catchability coefficients) via fit time-series data. ecostate also estimates additional process errors representing nonstationarity growth efficiency, ecotrophic efficient, migration, unmodeled processes. process errors allow biomass patterns closely match available data, resulting consumption (associated productivity mortality rates) can accurately conditioned upon residual patterns.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"ecostate can installed GitHub using: access vignettes R session, please instead use:","code":"library(remotes) install_github( \"James-Thorson-NOAA/ecostate\" ) remotes::install_github( \"James-Thorson-NOAA/ecostate\",                           build_vignettes = TRUE ) browseVignettes(\"ecostate\")"},{"path":"/index.html","id":"more-details","dir":"","previous_headings":"","what":"More details","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"background, please read:","code":""},{"path":"/index.html","id":"for-state-space-mass-balance-equilibrium-and-biomass-dynamic-modelling","dir":"","previous_headings":"","what":"For state-space mass-balance equilibrium and biomass-dynamic modelling","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"Thorson, J. Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. (press) benefits hierarchical ecosystem models: demonstration using new state-space mass-balance model EcoState. Fish Fisheries. https://doi.org/10.1111/faf.12874","code":""},{"path":"/index.html","id":"for-age-structured-dynamics-and-bottom-up-linkages-to-animal-growth","dir":"","previous_headings":"","what":"For age-structured dynamics and bottom-up linkages to animal growth:","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"Thorson, J. T., Aydin, K. H., Cheng, M., Dias, B. S., Kimmel, D. G., & Kristensen, K. (2025). Bottom-interactions age-structured stock assessment state-space mass-balance modelling. https://ecoevorxiv.org/repository/view/8411/","code":""},{"path":"/index.html","id":"for-original-development-of-ecopath-for-mass-balance-equilibria","dir":"","previous_headings":"","what":"For original development of ecopath for mass-balance equilibria:","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"Polovina, J. J. (1984). Model coral reef ecosystem. Coral Reefs, 3(1), 1â€“11. https://doi.org/10.1007/BF00306135","code":""},{"path":"/index.html","id":"for-development-of-ecosim-for-deterministic-biomass-and-age-structured-dynamics","dir":"","previous_headings":"","what":"For development of ecosim for deterministic biomass and age-structured dynamics:","title":"State-Space Mass-Balance Model for Marine Ecosystems","text":"Christensen, V., & Walters, C. J. (2004). Ecopath Ecosim: Methods, capabilities limitations. Ecological Modelling, 172(2), 109â€“139. https://doi.org/10.1016/j.ecolmodel.2003.09.003 Walters, C., Christensen, V., & Pauly, D. (1997). Structuring dynamic models exploited ecosystems trophic mass-balance assessments. Reviews Fish Biology Fisheries, 7(2), 139â€“172. https://doi.org/10.1023/:1018479526149 Walters, C., Pauly, D., Christensen, V., & Kitchell, J. F. (2000). Representing Density Dependent Consequences Life History Strategies Aquatic Ecosystems: EcoSim II. Ecosystems, 3(1), 70â€“83. https://doi.org/10.1007/s100210000011","code":""},{"path":"/reference/abm3pc_sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","title":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","text":"Third-order Adams-Bashford-Moulton predictor-corrector method.","code":""},{"path":"/reference/abm3pc_sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","text":"","code":"abm3pc_sys(f, a, b, y0, n, Pars, ...)"},{"path":"/reference/abm3pc_sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n number steps Pars named list parameters passed f ... additional inputs function f","code":""},{"path":"/reference/abm3pc_sys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","text":"List components x grid points b y n--m matrix solutions variables columns, .e. row contains one time stamp.","code":""},{"path":"/reference/abm3pc_sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adams-Bashford-Moulton for system of equations â€” abm3pc_sys","text":"Combined Adams-Bashford Adams-Moulton (: multi-step) method third order corrections according predictor-corrector approach. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/add_equilibrium.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute equilibrium values â€” add_equilibrium","title":"Compute equilibrium values â€” add_equilibrium","text":"Compute equilibrium values","code":""},{"path":"/reference/add_equilibrium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute equilibrium values â€” add_equilibrium","text":"","code":"add_equilibrium(ecoparams, scale_solver, noB_i, type_i)"},{"path":"/reference/add_equilibrium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute equilibrium values â€” add_equilibrium","text":"ecoparams list parameters scale_solver Whether solve ecotrophic efficiency EE given biomass B (scale_solver=\"simple\") solve combination EE B values noB_i Boolean vector indicating taxa B value type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\"","code":""},{"path":"/reference/add_equilibrium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute equilibrium values â€” add_equilibrium","text":"list parameters missing values ecoparams$B_i /ecoparams$EE_i filled , well additional values Qe_ij, m0_i, GE_i","code":""},{"path":"/reference/add_equilibrium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute equilibrium values â€” add_equilibrium","text":"Replaces NA values ecotrophic efficiency /biomass equilibrium solution, calculates equilibrium consumption, natural mortality, rates.","code":""},{"path":"/reference/compute_nll.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute negative log-likelihood for EcoState model â€” compute_nll","title":"Compute negative log-likelihood for EcoState model â€” compute_nll","text":"Compute negative log-likelihood EcoState model","code":""},{"path":"/reference/compute_nll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute negative log-likelihood for EcoState model â€” compute_nll","text":"","code":"compute_nll(   p,   taxa,   years,   noB_i,   type_i,   n_species,   project_vars,   Bobs_ti,   Cobs_ti,   Nobs_ta_g2,   Wobs_ta_g2,   log_prior,   fit_eps,   fit_nu,   sem,   stanza_data,   settings,   control,   simulate_data = FALSE,   simulate_random = FALSE )"},{"path":"/reference/compute_nll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute negative log-likelihood for EcoState model â€” compute_nll","text":"p list parameters taxa Character vector taxa included model. years Integer-vector years included model noB_i Boolean vector indicating taxa B value type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" n_species number species project_vars function integrate differential equation Bobs_ti formatted matrix biomass data Cobs_ti formatted matrix catch data Nobs_ta_g2 formatted list age-comp data Wobs_ta_g2 formatted list weight--age data log_prior list sampling statements representing parameter priors, user-provided function takes input list parameters $obj$env$parList() output ecostate(), returns numeric vector sum log-prior probability.  example log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE) specifies lognormal prior probability catchability coefficient first taxa logmean zero logsd 0.1. See evaluate_prior details. fit_eps Character-vector listing taxa model estimate annual process errors dB/dt fit_nu Character-vector listing taxa model estimate annual process errors consumption Q_ij sem Optional specification time-series structural equation model structure including lagged simultaneous effects. Process errors biomass, consumption, recruitment can included given taxa prefixing taxa names \"eps_\", \"nu_\", \"phi_\", respectively. E.g., specify autoregressive process biomass errors taxon named \"\", can specify path eps_i -> eps_i, 1, rho_i, 0 1 indicates lagged effect, rho_i user-provided parameter name, 0 starting value. See make_dsem_ram introduction DSEM path notation. make_dsem_ram introduction DSEM path notation. stanza_data output make_stanza_data settings Output stanza_settings(), used define age-structured dynamics (called stanza-groups). control output ecostate_control simulate_data Whether simulate new data instead computing objective function, used ecostate simulator routine simulate_random Whether simulate new values random effects. applies simulate_data==TRUE","code":""},{"path":"/reference/compute_nll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute negative log-likelihood for EcoState model â€” compute_nll","text":"joint negative log-likelihood including contribution priors fit data.","code":""},{"path":"/reference/compute_nll.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute negative log-likelihood for EcoState model â€” compute_nll","text":"Given list parameters, calculates joint negative log-likelihood, Laplace approximation used marginalize across random effects calculate log-marginal likelihood fixed effects. joint likelihood includes fit fishery catches, biomass indices, age-composition data, weight--age data, priors, distribution random effects.","code":""},{"path":"/reference/compute_tracer.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tracers, e.g., trophic level â€” compute_tracer","title":"Calculate tracers, e.g., trophic level â€” compute_tracer","text":"Calculate tracer propagates consumption.","code":""},{"path":"/reference/compute_tracer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tracers, e.g., trophic level â€” compute_tracer","text":"","code":"compute_tracer(   Q_ij,   inverse_method = c(\"Penrose_moore\", \"Standard\"),   type_i,   tracer_i = rep(1, nrow(Q_ij)) )"},{"path":"/reference/compute_tracer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tracers, e.g., trophic level â€” compute_tracer","text":"Q_ij Consumption prey predator j units biomass. inverse_method whether use pseudoinverse standard inverse type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" tracer_i indicator matrix specifying traver value","code":""},{"path":"/reference/compute_tracer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate tracers, e.g., trophic level â€” compute_tracer","text":"vector $$\\mathbf{y_i}$$ resulting tracer $$\\mathbf{x_i}$$","code":""},{"path":"/reference/compute_tracer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate tracers, e.g., trophic level â€” compute_tracer","text":"Trophic level \\(y_i\\) predator \\(\\) defined : $$ \\mathbf{y = l Q^* + 1} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level. generically, tracer might used track movement biomass consumption.  example, tracer \\(x_i\\) 1 base pelagic food chain, 0 otherwise, can calculate proportion pelagic vs. nonpelagic biomass taxon: $$ \\mathbf{y = l Q^* + x} $$ allows us separate alternative components foodweb.","code":""},{"path":"/reference/dBdt.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamics from EcoSim â€” dBdt","title":"Dynamics from EcoSim â€” dBdt","text":"Compute system differential equations representing EcoState dynamics derived EcoSim.","code":""},{"path":"/reference/dBdt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamics from EcoSim â€” dBdt","text":"","code":"dBdt(   Time,   State,   Pars,   type_i,   n_species,   F_type = \"integrated\",   what = \"dBdt\" )"},{"path":"/reference/dBdt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamics from EcoSim â€” dBdt","text":"Time used State vector state variables integrate Pars list parameters governing ODE type_i type taxon n_species number species F_type whether integrate catches along biomass (\"integrated\") calculate catches Baranov catch equation applied average biomass (\"averaged\") output produce","code":""},{"path":"/reference/dBdt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamics from EcoSim â€” dBdt","text":"object (list) ranges. Elements include: G_i Biomass growth per time g_i Biomass growth per time per biomass M2_i Consumptive mortality per time m2_i Consumptive mortality per time per biomass M_i Natural mortality per time m_i Natural mortality per time per biomass (.e., m2_i + m0_i) Q_ij Consumption per time prey (rows) predator (columns)","code":""},{"path":"/reference/dBdt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dynamics from EcoSim â€” dBdt","text":"function syntax designed match pracma solvers.","code":""},{"path":"/reference/ddirmult.html","id":null,"dir":"Reference","previous_headings":"","what":"Dirichlet-multinomial â€” ddirmult","title":"Dirichlet-multinomial â€” ddirmult","text":"Allows data-weighting parameter","code":""},{"path":"/reference/ddirmult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dirichlet-multinomial â€” ddirmult","text":"","code":"ddirmult(x, prob, ln_theta, log = TRUE)"},{"path":"/reference/ddirmult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dirichlet-multinomial â€” ddirmult","text":"x numeric vector observations across categories prob numeric vector category probabilities ln_theta logit-ratio effective input sample size log whether return log-probability ","code":""},{"path":"/reference/ddirmult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dirichlet-multinomial â€” ddirmult","text":"log-likelihood resulting Dirichlet-multinomial distribution","code":""},{"path":"/reference/ddirmult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dirichlet-multinomial â€” ddirmult","text":"","code":"library(RTMB) prob = rep(0.1,10) x = rmultinom( n=1, prob=prob, size=20 )[,1] f = function( ln_theta ) ddirmult(x, prob, ln_theta) f( 0 ) #> [1] -15.26349 F = MakeTape(f, 0) F$jacfun()(0) #>          [,1] #> [1,] 0.850599"},{"path":"/reference/eastern_bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"eastern Bering Sea ecosystem data â€” eastern_bering_sea","title":"eastern Bering Sea ecosystem data â€” eastern_bering_sea","text":"Data used demonstrate Model Intermediate Complexity (MICE) eastern Bering Sea. data(eastern_bering_sea) loads list includes four components: Survey long-form data-frame three columns, providing Year, Mass (relative units taxa, million metric tons Pollock, Cod, Arrowtooth, NFS), Taxon year available data Catch long-form data-frame three columns, providing Year, Mass (million metric tons), Taxon year available data P_over_B numeric vector unitless ratio biomass production population biomass taxon (vector names) Q_over_B numeric vector unitless ratio biomass consumption population biomass taxon (vector names) Diet_proportions numeric matrix column lists proportion biomass consumed predator (column names) provided prey (row names)","code":""},{"path":"/reference/eastern_bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"eastern Bering Sea ecosystem data â€” eastern_bering_sea","text":"","code":"data(eastern_bering_sea)"},{"path":"/reference/eastern_bering_sea.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"eastern Bering Sea ecosystem data â€” eastern_bering_sea","text":"data compiled come variety sources: Northern fur seal (NFS) survey absolute index, corrected proportion time spent eastern Bering Sea.  NFS QB developed bioenergetic model also corrected seasonal residency. provided Elizabeth McHuron. post-processed variety ways, treated index abundance NFS uses. Pollock, cod, arrowtooth surveys bottom trawl survey, cod arrowtooth treated absolute index. Copepod zooplankton oblique tow bongo net survey, data provided Dave Kimmel.  post-processed account spatially seaonally imbalanced data. P_over_B, Q_over_B Diet_proportions values derived Rpath models, provided Andy Whitehouse. Primary producers annual index relative biomass, developed monthly satellite measurements provided Jens Nielsen. See Thorson et al. (2025) details regarding data standardization sources","code":""},{"path":"/reference/ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"fit EcoState model â€” ecostate","title":"fit EcoState model â€” ecostate","text":"Estimate parameters EcoState model","code":""},{"path":"/reference/ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fit EcoState model â€” ecostate","text":"","code":"ecostate(   taxa,   years,   catch = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),   biomass = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),   agecomp = list(),   weight = list(),   PB,   QB,   B,   DC,   EE,   X,   type,   U,   fit_B = vector(),   fit_Q = vector(),   fit_B0 = vector(),   fit_EE = vector(),   fit_PB = vector(),   fit_QB = vector(),   fit_eps = vector(),   fit_nu = vector(),   sem = \"\",   covariates = NULL,   log_prior = function(p) 0,   settings = stanza_settings(taxa = taxa),   control = ecostate_control() )"},{"path":"/reference/ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fit EcoState model â€” ecostate","text":"taxa Character vector taxa included model. years Integer-vector years included model catch long-form data frame columns Mass, Year  Taxon biomass long-form data frame columns Mass, Year  Taxon, Mass assumed units catch agecomp named list, names corresponding stanza_groups, list-element matrix rownames years colnames integer ages, NA excludes entry inclusion model computes likelihood across included ages given year, rowsum input-sample size given year weight named list, names corresponding stanza_groups, list-element matrix rownames years colnames integer ages, NA excludes entry inclusion model computes lognormal likelihood weight--age specified age-year combination PB numeric-vector names matching taxa, providing ratio production biomass taxon QB numeric-vector names matching taxa, providing ratio consumption biomass taxon B numeric-vector names matching taxa, providing starting (fixed) value equilibrium biomass taxon DC numeric-matrix rownames colnames matching taxa, column provides diet proportion given predator EE numeric-vector names matching taxa, providing proportion proportion production subsequently modeled (termed ecotrophic efficiency) X numeric-matrix rownames colnames matching taxa, element gives vulnerability parameter given interaction. type character-vector names matching taxa elements c(\"auto\",\"hetero\",\"detritus\"), indicating whether taxon primary producer, consumer/predator, detritus, respectively. U numeric-vector names matching taxa, providing proportion consumption unassimilated therefore exported detritus fit_B Character-vector listing taxa equilibrium biomass estimated fixed effect fit_Q Character-vector listing taxa catchability coefficient estimated fixed effect fit_B0 Character-vector listing taxa ratio initial equilibrium biomass estimated fixed effect fit_EE Character-vector listing taxa ecotrophic efficiency estimated. fit_PB Character-vector listing taxa equilibrium production per biomass estimated.  Note likely good idea include prior species estimated. fit_QB Character-vector listing taxa equilibrium consumption per biomass estimated.  Note likely good idea include prior species estimated. fit_eps Character-vector listing taxa model estimate annual process errors dB/dt fit_nu Character-vector listing taxa model estimate annual process errors consumption Q_ij sem Optional specification time-series structural equation model structure including lagged simultaneous effects. Process errors biomass, consumption, recruitment can included given taxa prefixing taxa names \"eps_\", \"nu_\", \"phi_\", respectively. E.g., specify autoregressive process biomass errors taxon named \"\", can specify path eps_i -> eps_i, 1, rho_i, 0 1 indicates lagged effect, rho_i user-provided parameter name, 0 starting value. See make_dsem_ram introduction DSEM path notation. make_dsem_ram introduction DSEM path notation. covariates Matrix covariates (one row per year) use dynamic structural equation model process errors. log_prior list sampling statements representing parameter priors, user-provided function takes input list parameters $obj$env$parList() output ecostate(), returns numeric vector sum log-prior probability.  example log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE) specifies lognormal prior probability catchability coefficient first taxa logmean zero logsd 0.1. See evaluate_prior details. settings Output stanza_settings(), used define age-structured dynamics (called stanza-groups). control Output ecostate_control(), used define user settings.","code":""},{"path":"/reference/ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fit EcoState model â€” ecostate","text":"object (list) S3-class ecostate. Elements include: obj RTMB object MakeADFun tmb_inputs list inputs passed MakeADFun opt output nlminb sdrep output sdreport interal Objects useful package function, .e., arguments passed call rep report file, including matrix B_ti biomass year t taxon , g_ti growth rate per biomass, see dBdt quantities reported year derived derived quantity estimates standard errors, rep objects requested call function call record run_time Total runtime S3 class functions summary, print, logLik","code":""},{"path":"/reference/ecostate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fit EcoState model â€” ecostate","text":"taxa must included QB, PB, B, DC, additional taxa can QB, PB, B, DC taxa.  taxa can used redefine set modeled species without changing inputs","code":""},{"path":"/reference/ecostate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"fit EcoState model â€” ecostate","text":"Introducing state-space mass-balance model: Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.(press). benefits hierarchical ecosystem models: demonstration using new state-space mass-balance model EcoState. Fish Fisheries.","code":""},{"path":"/reference/ecostate_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for ecostate structure â€” ecostate_control","title":"Detailed control for ecostate structure â€” ecostate_control","text":"Define list control parameters.","code":""},{"path":"/reference/ecostate_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for ecostate structure â€” ecostate_control","text":"","code":"ecostate_control(   nlminb_loops = 1,   newton_loops = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   silent = getOption(\"ecostate.silent\", TRUE),   trace = getOption(\"ecostate.trace\", 0),   verbose = getOption(\"ecostate.verbose\", FALSE),   profile = c(\"logF_ti\", \"log_winf_z\", \"s50_z\", \"srate_z\"),   random = c(\"epsilon_ti\", \"alpha_ti\", \"nu_ti\", \"phi_tg2\", \"covariates\"),   tmb_par = NULL,   map = NULL,   getJointPrecision = FALSE,   integration_method = c(\"ABM\", \"RK4\", \"ode23\", \"rk4\", \"lsoda\"),   process_error = c(\"epsilon\", \"alpha\"),   n_steps = 10,   F_type = c(\"integrated\", \"averaged\"),   derived_quantities = c(\"h_g2\", \"B_ti\", \"B0_i\"),   scale_solver = c(\"joint\", \"simple\"),   inverse_method = c(\"Standard\", \"Penrose_moore\"),   tmbad.sparse_hessian_compress = 1,   start_tau = 0.001 )"},{"path":"/reference/ecostate_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for ecostate structure â€” ecostate_control","text":"nlminb_loops Integer number times call stats::nlminb(). newton_loops Integer number Newton steps running stats::nlminb(). eval.max Maximum number evaluations objective function allowed. Passed control stats::nlminb(). iter.max Maximum number iterations allowed. Passed control stats::nlminb(). getsd Boolean indicating whether call TMB::sdreport() silent Disable terminal output inner optimizer? trace Parameter values printed every trace iteration outer optimizer. Passed control stats::nlminb(). verbose Output additional messages model steps fitting? profile parameters profiled across, passed MakeADFun random parameters treated random effects, passed MakeADFun tmb_par list parameters starting values, shape identical tinyVAST(...)$internal$parlist map list mapping values, passed RTMB::MakeADFun getJointPrecision whether get joint precision matrix.  Passed sdreport. integration_method numerical integration method use. \"ABM\" uses native-R versions Adam-Bashford, \"RK4\" uses native-R version Runge-Kutta-4, \"ode23\" uses native-R version adaptive Runge-Kutta-23, adapted pracma functions. \"rk4\" lsoda use methods deSolve::ode implemented RTMBode::ode process_error Whether include process error continuous rate (.e., \"innovation\" parameterization, process_error=\"epsilon\") discrete difference expected predicted biomass (.e., \"state-space\" parameterization), process_error=\"alpha\"former interpretable, whereas latter much computationally efficient. n_steps number steps used ODE solver biomass dynamics F_type whether integrate catches along biomass (\"integrated\") calculate catches Baranov catch equation applied average biomass (\"averaged\") derived_quantities character-vector listing objects ADREPORT scale_solver Whether solve ecotrophic efficiency EE given biomass B (scale_solver=\"simple\") solve combination EE B values inverse_method whether use pseudoinverse standard inverse tmbad.sparse_hessian_compress passed TMB::config(), enabling experimental feature save memory first computing inner Hessian matrix.  Using tmbad.sparse_hessian_compress=1 seems effect MLE (although users probably confirm ), hugely reduces memory use small large models. Using tmbad.sparse_hessian_compress=1 seems hugely speed model-fitting large model results small decrease speed model-fitting small model. start_tau Starting value standard deviation process errors","code":""},{"path":"/reference/ecostate_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detailed control for ecostate structure â€” ecostate_control","text":"S3 object class \"ecostate_control\" specifies detailed model settings, allowing user specification also specifying default values","code":""},{"path":"/reference/evaluate_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"EcoState priors â€” evaluate_prior","title":"EcoState priors â€” evaluate_prior","text":"EcoState priors","code":""},{"path":"/reference/evaluate_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EcoState priors â€” evaluate_prior","text":"","code":"evaluate_prior(priors, p)"},{"path":"/reference/evaluate_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EcoState priors â€” evaluate_prior","text":"priors Either: list sampling statements (e.g., logtau_i[] ~ dnorm(mean = log(0.5), sd = 1)) named parameters. See \"Details\" list parameters descriptions. function takes input list parameters $obj$env$parList() output ecostate(), returns numeric vector sum log-prior probability.  example log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE) specifies lognormal prior probability catchability coefficient first taxa logmean zero logsd 0.1 p List parameters","code":""},{"path":"/reference/evaluate_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"EcoState priors â€” evaluate_prior","text":"Log-prior density (numeric)","code":""},{"path":"/reference/evaluate_prior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"EcoState priors â€” evaluate_prior","text":"Priors can specified list sampling statements, parameter names left-hand side density functions named arguments right-hand side. SEM parameters referred names, parameters indexed (e.g., taxa, year, stanza group) specified brackets. E.g., following list specifies priors SEM parameter named rho_X, biomass process errors time steps taxa Y epsilon_ti[,\"Y\"], ecotrophic efficiency taxa:","code":"priors <- list(    rho_X ~ dnorm(mean = 0, sd = 0.5),    epsilon_ti[,\"Y\"] ~ dnorm(mean = 0, sd = 0.1),    EE_i[] ~ dnorm(mean = 1, sd = 0.1)  )"},{"path":"/reference/ginv.html","id":null,"dir":"Reference","previous_headings":"","what":"Penrose-Moore pseudoinverse â€” ginv","title":"Penrose-Moore pseudoinverse â€” ginv","text":"Extend MASS:ginv work RTMB","code":""},{"path":"/reference/ginv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penrose-Moore pseudoinverse â€” ginv","text":"","code":"ginv(x)"},{"path":"/reference/ginv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penrose-Moore pseudoinverse â€” ginv","text":"x Matrix used compute pseudoinverse","code":""},{"path":"/reference/goa_mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Output from optimizer for GOA stanza example â€” goa_mle","title":"Output from optimizer for GOA stanza example â€” goa_mle","text":"Objective function MLE coefficients GOA stanza example","code":""},{"path":"/reference/goa_mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Output from optimizer for GOA stanza example â€” goa_mle","text":"","code":"data(goa_mle)"},{"path":"/reference/gulf_of_alaska.html","id":null,"dir":"Reference","previous_headings":"","what":"eastern Gulf of Alaska data â€” gulf_of_alaska","title":"eastern Gulf of Alaska data â€” gulf_of_alaska","text":"Data used demonstrate size-structured modelling including bottom-linkages. data(gulf_of_alaska) loads list includes four components: years set years modeled taxa set taxa (including stanza age-structured populations) type character vector indicating taxon (vector names) whether heterotroph, autotroph, detritus pool biomass_data long-form data-frame three columns, providing Year, Mass (relative units copepods euphausiids, million metric tons Pollock sablefish), Taxon year available data catch_data long-form data-frame three columns, providing Year, Mass (million metric tons), Taxon year available data P_over_B numeric vector unitless ratio biomass production population biomass taxon (vector names) Q_over_B numeric vector unitless ratio biomass consumption population biomass taxon (vector names) EE numeric vector ecotrophic efficiency taxa, case provided detritus pool determining turn-rate Diet_proportions numeric matrix column lists proportion biomass consumed predator (column) provided prey (row) agecomp_data named list age-composition samples age-structured population (named list element), list element matrix named rows indicating years, columns indicating integer ages stanza_groups character vector names matching taxa, elements indicating multi-stanza groups (.e., age-structured populations) Amax numeric vector indicating maximum age (years) stanza indicated names(stanza_groups). Leading Boolean vector indicating stanza used estimating biomass (therefore recruitment) names(stanza_groups). K numeric vector generalized von Bertalanffy growth coefficient (weight length) unique(stanza_groups) d numeric vector generalized von Bertalanffy growth coefficient (weight length) unique(stanza_groups) Amat numeric vector age 50% maturity (years) unique(stanza_groups). provided, used back-calculate replace value Wmat Wmat numeric vector weight 50% maturity (relative W_inf) unique(stanza_groups). Wmatslope numeric vector slope logistic maturity weight (relative W_inf) unique(stanza_groups)","code":""},{"path":"/reference/gulf_of_alaska.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"eastern Gulf of Alaska data â€” gulf_of_alaska","text":"","code":"data(gulf_of_alaska)"},{"path":"/reference/gulf_of_alaska.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"eastern Gulf of Alaska data â€” gulf_of_alaska","text":"data compiled come variety sources: Sablefish biomass index age-comps cooperative longline survey, index treated relative index. Pollock biomass index age-comps bottom trawl survey, index treated relative index prior catchability coefficient. Copepod biomass oblique tow bongo net survey, data provided Dave Kimmel. Euphausiid biomass Seward Long-Term Ecological Research program, provided Russ Hopcroft Ecological Status Report. P_over_B, Q_over_B Diet_proportions values derived Rpath models, provided Bia Dias. Age-structed inputs determined based life-history information biological samples. See Thorson et al. (review) details regarding data standardization sources","code":""},{"path":"/reference/logLik.ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal log-likelihood â€” logLik.ecostate","title":"Marginal log-likelihood â€” logLik.ecostate","text":"Extract (marginal) log-likelihood ecostate model","code":""},{"path":"/reference/logLik.ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal log-likelihood â€” logLik.ecostate","text":"","code":"# S3 method for class 'ecostate' logLik(object, ...)"},{"path":"/reference/logLik.ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal log-likelihood â€” logLik.ecostate","text":"object Output ecostate ... used","code":""},{"path":"/reference/logLik.ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal log-likelihood â€” logLik.ecostate","text":"object class logLik attributes val log-likelihood df number parameters Returns object class logLik. attributes \"df\" (degrees freedom) giving number (estimated) fixed effects model, abd \"val\" (value) giving marginal log-likelihood. class allows AIC work expected.","code":""},{"path":"/reference/ode23.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-stiff (and stiff) ODE solvers â€” ode23","title":"Non-stiff (and stiff) ODE solvers â€” ode23","text":"Runge-Kutta (2, 3)-method variable step size, resp","code":""},{"path":"/reference/ode23.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-stiff (and stiff) ODE solvers â€” ode23","text":"","code":"ode23(f, a, b, y0, n, Pars, rtol = 0.001, atol = 1e-06)"},{"path":"/reference/ode23.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-stiff (and stiff) ODE solvers â€” ode23","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n used Pars named list parameters passed f rtol relative tolerance. atol absolute tolerance.","code":""},{"path":"/reference/ode23.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-stiff (and stiff) ODE solvers â€” ode23","text":"List components t time points b y n--m matrix solutions variables columns, .e. row contains one time stamp.","code":""},{"path":"/reference/ode23.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-stiff (and stiff) ODE solvers â€” ode23","text":"Copied pracma GPL-3, small modifications work RTMB. can used simulate dynamics, estimation","code":""},{"path":"/reference/plot_foodweb.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot foodweb â€” plot_foodweb","title":"Plot foodweb â€” plot_foodweb","text":"Plot consumption directed graph including taxa (vertices) biomass consumed (arrows).  Taxa located using tracers, default y-axis trophic level.  #'","code":""},{"path":"/reference/plot_foodweb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot foodweb â€” plot_foodweb","text":"","code":"plot_foodweb(   Q_ij,   type_i,   xtracer_i,   ytracer_i = rep(1, nrow(Q_ij)),   B_i = rep(1, nrow(Q_ij)),   taxa_labels = letters[1:nrow(Q_ij)],   xloc,   yloc )"},{"path":"/reference/plot_foodweb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot foodweb â€” plot_foodweb","text":"Q_ij Consumption prey predator j units biomass. type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" xtracer_i tracer use computing x-axis values ytracer_i tracer use computing y-axis values B_i biomass use weighting taxa plot taxa_labels character vector labels use taxon xloc x-axis location (overrides calculation using xtracer_i) yloc y-axis location (overrides calculation using ytracer_i)","code":""},{"path":"/reference/plot_foodweb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot foodweb â€” plot_foodweb","text":"invisibly return ggplot object foodweb","code":""},{"path":"/reference/plot_foodweb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot foodweb â€” plot_foodweb","text":"Trophic level \\(l_i\\) predator \\(\\) defined : $$ \\mathbf{l - 1 = l Q^*} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level.","code":""},{"path":"/reference/print.ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitted ecostate object â€” print.ecostate","title":"Print fitted ecostate object â€” print.ecostate","text":"Prints output fitted ecostate model","code":""},{"path":"/reference/print.ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitted ecostate object â€” print.ecostate","text":"","code":"# S3 method for class 'ecostate' print(x, ...)"},{"path":"/reference/print.ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitted ecostate object â€” print.ecostate","text":"x Output ecostate ... used","code":""},{"path":"/reference/print.ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print fitted ecostate object â€” print.ecostate","text":"return value, called provide clean terminal output calling fitted object terminal.","code":""},{"path":"/reference/print_ecopars.html","id":null,"dir":"Reference","previous_headings":"","what":"Print EcoSim parameters â€” print_ecopars","title":"Print EcoSim parameters â€” print_ecopars","text":"Prints parameters defining EcoSim dynamics","code":""},{"path":"/reference/print_ecopars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print EcoSim parameters â€” print_ecopars","text":"","code":"print_ecopars(x, silent = FALSE)"},{"path":"/reference/print_ecopars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print EcoSim parameters â€” print_ecopars","text":"x Output ecostate silent whether print terminal","code":""},{"path":"/reference/print_ecopars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print EcoSim parameters â€” print_ecopars","text":"invisibly returns table printed","code":""},{"path":"/reference/rk4sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Classical Runge-Kutta for system of equations â€” rk4sys","title":"Classical Runge-Kutta for system of equations â€” rk4sys","text":"Classical Runge-Kutta order 4.","code":""},{"path":"/reference/rk4sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classical Runge-Kutta for system of equations â€” rk4sys","text":"","code":"rk4sys(f, a, b, y0, n, Pars, ...)"},{"path":"/reference/rk4sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classical Runge-Kutta for system of equations â€” rk4sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n number steps b. Pars named list parameters passed f ... additional inputs function f","code":""},{"path":"/reference/rk4sys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classical Runge-Kutta for system of equations â€” rk4sys","text":"List components x grid points b y n--m matrix solutions variables columns, .e. row contains one time stamp.","code":""},{"path":"/reference/rk4sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classical Runge-Kutta for system of equations â€” rk4sys","text":"Classical Runge-Kutta order 4 (systems ) ordinary differential equations fixed step size. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/stanza_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for stanza structure â€” stanza_settings","title":"Detailed control for stanza structure â€” stanza_settings","text":"Define list control parameters.","code":""},{"path":"/reference/stanza_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for stanza structure â€” stanza_settings","text":"","code":"stanza_settings(   taxa,   stanza_groups,   K,   d,   Wmat,   Amax,   SpawnX,   Leading,   fit_K = c(),   fit_d = c(),   fit_phi = vector(),   Amat = NULL,   Wmatslope,   STEPS_PER_YEAR = 1,   comp_weight = c(\"multinom\", \"dir\", \"dirmult\") )"},{"path":"/reference/stanza_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for stanza structure â€” stanza_settings","text":"taxa Character vector taxa included model. stanza_groups character-vector names corresponding taxa elements specifying multi-stanza group (.e., age-structured population) given taxa K numeric-vector names matching unique(stanza_groups), providing von Bertalanffy growth coefficient length d numeric-vector names matching unique(stanza_groups), providing von Bertalanffy allometric consumption--weight (default 2/3) Wmat numeric-vector names matching unique(stanza_groups), providing weight--maturity relative asymptotic weight Amax numeric-vector names matching names(stanza_groups), providing maximum age  (units years) given taxon (oldest taxon given stanza_group treated plus-group) SpawnX numeric-vector names matching unique(stanza_groups), providing larval vulnerability (density dependence) parameter Leading Boolean vector names matching names(stanza_groups), TRUE taxon scale (B EE) specified estimated, calculated determinstically taxa given stanza_group fit_K Character-vector listing stanza_groups K estimated fit_d Character-vector listing stanza_groups d estimated (note currently work) fit_phi Character-vector listing stanza_groups model estimate annual recruitment deviations, representing nonconsumptive variation larval survival (e.g., oceanographic advection) Amat numeric-vector names matching unique(stanza_groups), providing integer age--maturity (units years) Wmatslope numeric-vector names matching unique(stanza_groups), providing slope 0.5 maturity logistic maturity--weight ogive STEPS_PER_YEAR integer number Euler steps per year calculating integrating individual weight--age comp_weight method used weighting age-composition data","code":""},{"path":"/reference/stanza_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detailed control for stanza structure â€” stanza_settings","text":"S3 object class \"stanza_settings\" specifies detailed model settings related age-structured dynamics (e.g., stanzas), allowing user specification also specifying default values","code":""},{"path":"/reference/whitehouse_2021.html","id":null,"dir":"Reference","previous_headings":"","what":"Full rpath inputs for eastern Bering Sea â€” whitehouse_2021","title":"Full rpath inputs for eastern Bering Sea â€” whitehouse_2021","text":"Rpath inputs Whitehouse et al. 2021","code":""},{"path":"/reference/whitehouse_2021.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full rpath inputs for eastern Bering Sea â€” whitehouse_2021","text":"","code":"data(whitehouse_2021)"},{"path":"/news/index.html","id":"ecostate-030","dir":"Changelog","previous_headings":"","what":"ecostate 0.3.0","title":"ecostate 0.3.0","text":"Added alternative interface specifying priors via tilda notation (h/t Maurice Goodman) Added DSEM interface specify process errors replacing forcing functions (Ecopath Ecosim) covariates, including direct indirect effects jointly imputing missing values (h/t Maurice Goodman) Added testthat integrated tests (h/t Maurice Goodman)","code":""},{"path":"/news/index.html","id":"ecostate-020","dir":"Changelog","previous_headings":"","what":"ecostate 0.2.0","title":"ecostate 0.2.0","text":"CRAN release: 2024-11-25 Added fit$simulator simulate new data conditional fitted specified parameters","code":""},{"path":"/news/index.html","id":"ecostate-010","dir":"Changelog","previous_headings":"","what":"ecostate 0.1.0","title":"ecostate 0.1.0","text":"Initial public release","code":""}]
