[{"path":"/articles/model_of_intermediate_complexity.html","id":"eastern-bering-sea","dir":"Articles","previous_headings":"","what":"Eastern Bering Sea","title":"Model of Intermediate Complexity","text":"first load Survey, Catch, PB, QB values, define biological inputs: fit function call. slow: can plot estimated foodweb:  Runtime vignette: 1.9 mins","code":"# load data data(eastern_bering_sea)  # Reformat inputs years = 1982:2021 # Catch only goes through 2021, and starting pre-data in 1982 doesn't play well with fit_B0 taxa = c( \"Pollock\", \"Cod\", \"Arrowtooth\", \"Copepod\", \"Other_zoop\", \"Chloro\", \"NFS\", \"Krill\", \"Benthic_invert\", \"Benthos\", \"Detritus\" )  # Define types type_i = sapply( taxa, FUN=switch, \"Detritus\" = \"detritus\",                                    \"Chloro\" = \"auto\",                                    \"hetero\" )  # Starting values U_i = EE_i = B_i = array( NA, dim=length(taxa),                      dimnames=list(names(eastern_bering_sea$P_over_B))) B_i[c(\"Cod\", \"Arrowtooth\", \"NFS\")] = c(1, 0.5, 0.02) EE_i[] = 1 U_i[] = 0.2  # Define default vulnerability, except for primary producers X_ij = array( 2, dim=c(length(taxa),length(taxa)) ) dimnames(X_ij) = list(names(B_i),names(B_i)) X_ij[,'Chloro'] = 91 # Define parameters to estimate fit_Q = c(\"Pollock\", \"Copepod\", \"Chloro\", \"Other_zoop\", \"Krill\") fit_B0 = c(\"Pollock\", \"Cod\", \"Arrowtooth\", \"NFS\") fit_B = c(\"Cod\", \"Arrowtooth\", \"NFS\")    # Define process errors to estimate # Only estimating Pollock to speed up demonstration fit_eps = \"Pollock\"  # Which taxa to include taxa_to_include = c( \"NFS\", \"Pollock\", \"Copepod\", \"Chloro\", \"Krill\" ) # To run full model use: # taxa_to_include = taxa  # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE) }  # Run model out = ecostate( taxa = taxa_to_include,                 years = years,                 catch = eastern_bering_sea$Catch,                 biomass = eastern_bering_sea$Survey,                 PB = eastern_bering_sea$P_over_B,                 QB = eastern_bering_sea$Q_over_B,                 DC = eastern_bering_sea$Diet_proportions,                 B = B_i,                 EE = EE_i,                 U = U_i,                 type = type_i,                 X = X_ij,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( n_steps = 20, # using 15 by default                                             start_tau = 0.01,                                             tmbad.sparse_hessian_compress = 0 ))  # print output out #> Dynamics integrated using  ABM  with  20  time-steps #> Run time: Time difference of 1.875662 mins #> Negative log-likelihood: 111.8524 #>  #> EcoSim parameters: #>           type        QB          PB          B EE   U #> NFS     hetero 57.763550  0.09429851 0.01609925  0 0.2 #> Pollock hetero  4.225892  0.82452074 3.26652224  1 0.2 #> Copepod hetero 27.740000  6.00000000 1.85225167  1 0.2 #> Chloro    auto        NA 99.40685006 0.63388263  1 0.2 #> Krill   hetero 15.640000  5.48000000 1.05351582  1 0.2 #>  #> EcoSim diet matrix: #>          Predator #> Prey      NFS   Pollock Copepod Chloro     Krill #>   NFS       0 0.0000000       0      0 0.0000000 #>   Pollock   1 0.1277434       0      0 0.0000000 #>   Copepod   0 0.4540243       0      0 0.2941176 #>   Chloro    0 0.0000000       1      0 0.7058824 #>   Krill     0 0.4182324       0      0 0.0000000 #>  #> EcoSim vulnerability matrix: #>         NFS Pollock Copepod Chloro Krill #> NFS       2       2       2     91     2 #> Pollock   2       2       2     91     2 #> Copepod   2       2       2     91     2 #> Chloro    2       2       2     91     2 #> Krill     2       2       2     91     2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> delta_i  -0.9107485 0.07412192 #> delta_i  -0.9712690 0.10263244 #> logB_i   -4.1289824 0.05667705 #> logtau_i -1.1467111 0.14112593 #> logq_i    0.9289014 0.05572851 #> logq_i    1.0002721 0.06744515 #> logq_i    2.6850118 0.05908211 #> logq_i    2.3987716 0.07547528 #> Maximum gradient component: 0.0001222253 # Plot foodweb at equilibrium # using pelagic producers as x-axis and trophic level as y-axis plot_foodweb( out$rep$out_initial$Qe_ij,                 xtracer_i = ifelse(taxa_to_include==\"Krill\",1,0),               B_i = out$rep$out_initial$B_i,               type_i = type_i[taxa_to_include] ) #> Warning: Removed 4 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"/articles/simulation.html","id":"simulation-demonstration","dir":"Articles","previous_headings":"","what":"Simulation demonstration","title":"Demonstrating EcoState via simulation","text":"first simulate new data. , specify 5-species ecosystem: first define function simulates data, using functions mass-balance simulating dynamics used EcoState parameter estimation:","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Name taxa (optional, for illustration) taxa = c(\"Consumer_1\", \"Consumer_2\", \"Predator_1\", \"Predator_2\", \"Producer\", \"Detritus\") n_species = length(taxa)  # Ecopath-with-EcoSim parameters # Diet matrix DC_ij = matrix( c(   0,     0,     0.8,  0.4,  0,   0,   0,     0,     0.2,  0.6,  0,   0,   0,     0,     0,    0,    0,   0,   0,     0,     0,    0,    0,   0,   0.9,   0.3,   0,    0,    0,   0,   0.1,   0.7,   0,    0,    0,   0 ), byrow=TRUE, ncol=n_species) PB_i = c( 4, 1, 0.2, 0.1, 90, 0.5 )         # Reciprocal of mean age according to Polovina-1984 ~= M QB_i = c( 10, 4, 3, 1, NA, NA ) EE_i = c( 0.9, 0.9, NA, NA, 0.9, 0.9 ) B_i = c( NA, NA, 1, 1, NA, NA ) U_i = rep( 0.2, n_species ) type_i = c( \"hetero\", \"hetero\", \"hetero\", \"hetero\", \"auto\", \"detritus\" ) which_primary = which(type_i==\"auto\") which_detritus = which(type_i==\"detritus\") X_ij = matrix( 2, nrow=n_species, ncol=n_species ) X_ij[,which_primary] = 91 simulate_data = function(){   # Simulate process errors   set.seed(101)   rarray = \\(x,dims=dim(x),sd) array( sd*rnorm(prod(dims)), dim=dims )   epsilon_ti = rarray(dims=c(n_years,n_species),sd=1) * outer(rep(1,n_years),sigmaB_i)      # Choose method to integrate instantaneous rates for annual dynamics   n_steps = 10   project_vars = abm3pc_sys      # Define parameters   Pars = list( logB_i = log( B_i ),                       logPB_i = log(PB_i),                      logQB_i = log(QB_i),                      Xprime_ij = log(X_ij - 1),                      EE_i = EE_i,                      DC_ij = DC_ij,                      U_i = U_i,                      type_i = type_i,                      noB_i = ifelse( is.na(B_i), 1, 0),                      epsilon_i = rep(0,n_species),                      logF_i = rep(-Inf,n_species) )                      #which_detritus = which_detritus,                      #which_primary = which_primary,                      #F_type = \"integrated\" )   Pars_full = add_equilibrium( Pars,                                scale_solver = \"joint\",                                noB_i = ifelse(is.na(Pars$logB_i),1,0),                                type_i = type_i )    # Project forward   Bobs_ti = Cobs_ti = B_ti = C_ti = array( NA, dim=c(n_years,n_species),                                      dimnames=list(\"Year\"=years,\"Taxon\"=taxa) )   B_ti[1,] = exp(Pars_full$logB_i)   C_ti[1,] = NA      for( t in seq_along(years)[-1] ){     # Fishing mortality ramps up for two predators     F_t = c( 0, 0, t/n_years*0.2, t/n_years*0.1, 0, 0 )        #     pars_t = Pars_full     pars_t$logF_i = log(F_t)     pars_t$epsilon_i = epsilon_ti[t,]     pars_t$nu_i = rep(0,n_species)      # Integrate dynamics annually     #data2 = local({     #                n_species = n_species     #                environment()     #})     #environment(dBdt) <- data2     sim = project_vars(           f = dBdt,           a = years[t-1],            b = years[t],           n = n_steps,           Pars = pars_t,           type_i = type_i,           n_species = n_species,           F_type = \"integrated\",           y0 = c( B_ti[t-1,], rep(0,n_species) ) )          # Record results     B_ti[t,] = sim$y[nrow(sim$y),seq_len(n_species)]     C_ti[t,] = sim$y[nrow(sim$y),n_species+seq_len(n_species)]        # Simulate measurement errors     Bobs_ti[t,] = B_ti[t,] * exp(0.1*rnorm(n_species))     Cobs_ti[t,] = ifelse(C_ti[t,]==0,NA,C_ti[t,]) * exp(0.1*rnorm(n_species))   }   return( list( \"B_ti\"=B_ti, \"C_ti\"=C_ti, \"Bobs_ti\"=Bobs_ti,                  \"Cobs_ti\"=Cobs_ti, \"Pars_full\"=Pars_full) ) }"},{"path":"/articles/simulation.html","id":"comparison-with-rpath","dir":"Articles","previous_headings":"","what":"Comparison with Rpath","title":"Demonstrating EcoState via simulation","text":"first compare functions used EcoState existing implementations model. One script-based implementation available R Rpath, therefore show syntax model-output comparison. comparison, first simulate data set process errors: load Rpath reformat inputs format expects calculate mass-balance: can simulate forward time using Rpath: Comparing scenario forecasted Rpath simulated time-series, see two closely match. EcoState uses functions fitting, also closely matches Rpath.","code":"sigmaB_i = c(0, 0, 0, 0, 0, 0) # Taxa 1-2 crashes solver if sigmaB > 0.02 sim = simulate_data() library(Rpath)  # Rpath needs types in ascending order (EcoState doesn't care) types  <- sapply( c(type_i,\"fishery\"), FUN=switch,                    \"hetero\"==0, \"auto\"=1, \"detritus\"=2, \"fishery\"=3 ) groups <- c( taxa, \"fishery\" ) stgroups = rep(NA, length(groups) ) REco.params <- create.rpath.params(group = groups, type = types, stgroup = stgroups)  # Fill in biomass #REco.params$model$Biomass = c( exp(Pars_full$logB_i), NA ) REco.params$model$Biomass = c( B_i, NA ) REco.params$model$EE = c( ifelse(type_i==\"detritus\",NA,EE_i), NA ) REco.params$model$PB = c( PB_i, NA ) REco.params$model$QB = c( QB_i, NA )  #Biomass accumulation and unassimilated consumption REco.params$model$BioAcc = c( rep(0,length(taxa)), NA ) REco.params$model$Unassim = c( ifelse(type_i==\"hetero\",0.2,0), NA )  #Detrital Fate REco.params$model$Detritus = c( ifelse(type_i==\"detritus\",0,1), 0 ) REco.params$model$fishery = c( rep(0,length(taxa)), NA ) REco.params$model$fishery.disc = c( rep(0,length(taxa)), NA )  # Diet for(j in 1:5) REco.params$diet[seq_along(taxa),j+1] = DC_ij[,j] REco.params$diet[seq_along(taxa),2] = DC_ij[,1]  # Balance using Ecopath equations check.rpath.params( REco.params) #> Rpath parameter file is functional. REco <- rpath(REco.params, eco.name = 'R Ecosystem') # Create simulation object REco.sim <- rsim.scenario(REco, REco.params, years = 1:40)  # REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_1', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.2 ) REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_2', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.1 )  # Match vulnerability for self-limitation in Producers REco.sim$params$VV[which(REco.sim$params$PreyFrom==0 & REco.sim$params$PreyTo==5)] = 91  #  REco.run1 <- rsim.run(REco.sim, method = 'RK4', years = 1:40) # Calculate annual simulated catch Year = rep( years, each=12) Bsim_ti = apply( REco.run1$out_Biomass[,-1], MARGIN=2, FUN=\\(x) tapply(x,INDEX=Year,FUN=mean) )  # par(mfrow=c(2,1), mar=c(3,3,1,1), mgp=c(2,0.5,0) ) matplot( x=years, y=Bsim_ti / outer(rep(1,n_years),Bsim_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Rpath)\", xlab=\"Year\" ) Brel_ti = sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]) matplot( x=years, y=sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Simulated)\", xlab=\"Year\" ) legend(\"bottomleft\", fill=rainbow(n_species), legend=taxa, ncol=2, bty=\"n\")"},{"path":"/articles/simulation.html","id":"fitting-the-model-using-ecostate","dir":"Articles","previous_headings":"","what":"Fitting the model using EcoState","title":"Demonstrating EcoState via simulation","text":"next want show EcoState performs fitting simulated data. simulate data set process errors, plot compare previous simulation process errors:  reformat simulated biomass catch time-series long-form data frames fit ecostate Finally, can extract elements fitted model, plot easily using ggplot2 compare known (simulated) values. exercise shows EcoState can accurately estimate biomass trends:","code":"# Simulate new data sigmaB_i = c(0.02, 0.02, 0.1, 0.1, 0.1, 0.1) # Taxa 1-2 crashes solver if sigmaB > 0.02 sim = simulate_data()  # Unload simulated data Bobs_ti = sim$Bobs_ti Cobs_ti = sim$Cobs_ti B_ti = sim$B_ti Pars_full = sim$Pars_full  # Plot simulation with process errors matplot( x=years, y=B_ti / outer(rep(1,n_years),B_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (simulated)\", xlab=\"Year\" ) # reformat to longform data-frame Catch = na.omit(data.frame(expand.grid(dimnames(Cobs_ti)), \"Mass\"=as.vector(Cobs_ti))) Biomass = na.omit(data.frame(expand.grid(dimnames(Bobs_ti)), \"Mass\"=as.vector(Bobs_ti)))  # Settings: specify what parameters to estimate fit_eps = c(\"Producer\", \"Detritus\", \"Predator_1\", \"Predator_2\")   # process errors fit_Q = c()       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass  # Solving for EE and giving uninformed initial values for biomass fittedB_i = exp(Pars_full$logB_i) fittedEE_i = rep(NA, n_species)  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(fittedB_i) = names(fittedEE_i) = names(type_i) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE) }  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( # Much faster to turn off                                             tmbad.sparse_hessian_compress = 0,                                             # Faster to profile these                                             profile = c(\"logF_ti\",\"logB_i\"),                                             # More stable when starting low                                             start_tau = 0.001 ))  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 2.102548 mins #> Negative log-likelihood: -257.8807 #>  #> EcoSim parameters: #>                type QB   PB         B        EE   U #> Consumer_1   hetero 10  4.0 0.7862833 0.8547194 0.2 #> Consumer_2   hetero  4  1.0 1.2979525 0.8762152 0.2 #> Predator_1   hetero  3  0.2 0.9650080 0.0000000 0.2 #> Predator_2   hetero  1  0.1 0.9304681 0.0000000 0.2 #> Producer       auto NA 90.0 0.1006972 0.9527011 0.2 #> Detritus   detritus NA  0.5 9.5823731 0.9226421 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1          2          2          2          2       91        2 #>   Consumer_2          2          2          2          2       91        2 #>   Predator_1          2          2          2          2       91        2 #>   Predator_2          2          2          2          2       91        2 #>   Producer            2          2          2          2       91        2 #>   Detritus            2          2          2          2       91        2 #>  #> Estimates: sdreport(.) result #>           Estimate Std. Error #> logtau_i -2.395457  0.1999421 #> logtau_i -2.528423  0.2809718 #> logtau_i -1.815466  0.7800328 #> logtau_i -2.160598  0.2680706 #> Maximum gradient component: 1.367582e-06 # Extract estimated biomass Bhat_ti = out$derived$Est$B_ti Bse_ti = out$derived$SE$B_ti  # Reformat to long-form data frame for ggplot results = expand.grid(dimnames(Bobs_ti)) results = cbind( results,                   \"True\" = as.vector(B_ti),                  \"Est\" = as.vector(Bhat_ti),                  \"SE\" = as.vector(Bse_ti) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True) ) +    facet_wrap( vars(Taxon), scale=\"free\" ) +   geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-SE, ymax=Est+SE), alpha=0.2)"},{"path":"/articles/simulation.html","id":"advanced-estimating-vulnerability-parameters","dir":"Articles","previous_headings":"","what":"Advanced: estimating vulnerability parameters","title":"Demonstrating EcoState via simulation","text":"can also explore estimating additional parameters. , explore estimating vulnerability: Runtime vignette: 4.67 mins","code":"# Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ), na.rm=TRUE)   # Prior on vulnerability to stabilize model (single value mirrored below)   logp = logp + dnorm( p$Xprime_ij[1,1], mean=0, sd=1, log=TRUE ) }  # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( inverse_method = \"Standard\",                                             nlminb_loops = 0,                                             tmbad.sparse_hessian_compress = 0,                                             getsd = FALSE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.1 ))  # Change tmb_par tmb_par = out0$tmb_inputs$p   tmb_par$Xprime_ij[,which(type_i!=\"auto\")] = log(1.5 - 1) map = out0$tmb_inputs$map   map$Xprime_ij = array(NA, dim=dim(tmb_par$Xprime_ij))   map$Xprime_ij[,which(type_i!=\"auto\")] = 1   map$Xprime_ij = factor(map$Xprime_ij)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control( inverse_method = \"Standard\",                                             nlminb_loops = 1,                                             tmbad.sparse_hessian_compress = 0,                                             getsd = TRUE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.001,                                             tmb_par = tmb_par,                                             map = map ))   # alpha is faster than epsilon #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 2.504987 mins #> Negative log-likelihood: -256.9749 #>  #> EcoSim parameters: #>                type QB   PB         B        EE   U #> Consumer_1   hetero 10  4.0 0.7859114 0.8583339 0.2 #> Consumer_2   hetero  4  1.0 1.2992375 0.8788253 0.2 #> Predator_1   hetero  3  0.2 0.9685480 0.0000000 0.2 #> Predator_2   hetero  1  0.1 0.9344566 0.0000000 0.2 #> Producer       auto NA 90.0 0.1008355 0.9511963 0.2 #> Detritus   detritus NA  0.5 9.5883393 0.9227409 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1   1.977243   1.977243   1.977243   1.977243       91 1.977243 #>   Consumer_2   1.977243   1.977243   1.977243   1.977243       91 1.977243 #>   Predator_1   1.977243   1.977243   1.977243   1.977243       91 1.977243 #>   Predator_2   1.977243   1.977243   1.977243   1.977243       91 1.977243 #>   Producer     1.977243   1.977243   1.977243   1.977243       91 1.977243 #>   Detritus     1.977243   1.977243   1.977243   1.977243       91 1.977243 #>  #> Estimates: sdreport(.) result #>              Estimate Std. Error #> Xprime_ij -0.02302001  0.1539942 #> logtau_i  -2.39718954  0.2012940 #> logtau_i  -2.51981549  0.2867294 #> logtau_i  -1.77412399  0.8408468 #> logtau_i  -2.15986779  0.2684473 #> Maximum gradient component: 2.810887e-05"},{"path":"/articles/surplus_production.html","id":"simulation-demonstration","dir":"Articles","previous_headings":"","what":"Simulation demonstration","title":"EcoState as surplus production model","text":"first simulate new data. , simulate Schaefer production model Gompertz effort dynamics:  set inputs EcoState Next, fit ecostate Finally can calculate function calculates annualized surplus production use function compare exact approximation uses first-order Euler approximation:  can also plot estimated true biomass","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Biology r = 0.2 #MSY = 100 K = 1000 sigmaB = 0.5 B0 = K * exp(sigmaB*rnorm(1)) prod_func = c(\"Schaefer\", \"Fox\")[2]  # Effort dynamics Bequil = 0.4 * K Brate = 0.2 sigmaE = 0.1 E0 = 0.01  # Survey q = 1 sigmaQ = 0.1  # Pbar_t = P_t = C_t = E_t = B_t = rep(NA, n_years) B_t[1] = B0 E_t[1] = E0  # for( t in 2:n_years ){   if(prod_func==\"Scaefer\") Pbar_t[t] = B_t[t-1] + r * B_t[t-1] * (1 - B_t[t-1]/K)   if(prod_func==\"Fox\") Pbar_t[t] = r * B_t[t-1] * log(K / B_t[t-1])   P_t[t] = Pbar_t[t] * exp(sigmaB*rnorm(1))   B_t[t] = B_t[t-1] + P_t[t]   E_t[t] = E_t[t-1] * (B_t[t-1]/Bequil)^Brate * exp(sigmaE*rnorm(1))   C_t[t] = B_t[t] * (1 - exp(-E_t[t]))   B_t[t] = B_t[t] - C_t[t] } Bobs_t = q * B_t * exp(sigmaQ * rnorm(n_years))  #  matplot( x=years, y=cbind(B_t,Bobs_t,C_t), type=\"l\", log=\"y\", lty=\"solid\") # Name taxa (optional, for illustration) taxa = \"target\" n_taxa = length(taxa)  # Ecopath-with-EcoSim parameters # Diet matrix DC_ij = array( 0, dim=c(1,1) ) PB_i = 0.1 QB_i = NA EE_i = 1 B_i = 1 U_i = 0.2 type_i = \"auto\" X_ij = array( 2, dim=c(1,1) )  # reformat to longform data-frame Catch = na.omit(data.frame( \"Mass\" = C_t, \"Year\" = years, \"Taxon\" = taxa )) Biomass = data.frame( \"Mass\" = Bobs_t, \"Year\" = years, \"Taxon\" = taxa ) # Settings: specify what parameters to estimate fit_eps = taxa   # process errors fit_Q = taxa       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass fit_PB = taxa     # Productivity _propto_ natural mortality  # Treat it as an autotroph (given there's no prey to consume) type = \"auto\"  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on productivity   logp = dnorm( p$logPB_i, mean=log(0.1), sd=0.5, log=TRUE )   # Prior on process-error log-SD to stabilize model   logp = logp + dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE )   # Prior on vulnerability to stabilize model   logp = logp + dnorm( p$Xprime_ij[1,1], mean=0, sd=1, log=TRUE ) }  # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 fit_PB = fit_PB,                 log_prior = log_prior,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = FALSE,                                             start_tau = 0.1 ) )  # Estimate logPB pars = out0$tmb_inputs$p map = out0$tmb_inputs$map map$Xprime_ij = factor(1)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 fit_PB = fit_PB,                 log_prior = log_prior,                 control = ecostate_control( map = map,                                             tmb_par = pars ) ) #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 4.749453 secs #> Negative log-likelihood: -74.51341 #>  #> EcoSim parameters: #>        type QB        PB        B EE   U #> target auto NA 0.1588959 1357.543  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     target #>   target      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey       target #>   target 1.357989 #>  #> Estimates: sdreport(.) result #>             Estimate Std. Error #> logB_i     7.2134320  0.3091545 #> logPB_i   -1.8395058  0.4064990 #> Xprime_ij -1.0272522  0.6851844 #> logtau_i  -3.0608084  0.4094129 #> logq_i    -0.3785607  0.3285576 #> Maximum gradient component: 0.000126564 # Define function to calculate annualized production prod_fun = function( biomass, Xprime, logPB, taxon, ecofit ){   p = ecofit$internal$parhat   n_taxa = length(ecofit$internal$taxa)   if(!missing(Xprime)) p$Xprime_ij[] = Xprime   if(!missing(logPB)) p$logPB_i[] = logPB   if(missing(taxon)) taxon = ecofit$internal$taxa[n_taxa]   p = add_equilibrium( p,                        scale_solver = ecofit$internal$control$scale_solver,                        noB_i = ifelse(is.na(p$logB_i),1,0),                        type_i = type_i )   p$logF_i = rep(log(0), n_taxa)   p$epsilon_i = rep(0, n_taxa)   p$nu_i = rep(0, n_taxa)   p$phi_g2 = rep(0, ecofit$internal$settings$n_g2)   State = c( ecofit$rep$out_initial$B_i, rep(0,n_taxa) )   State[match(taxon,ecofit$internal$taxa)] = biomass   #dBdt(Time=0, State=State, Pars=p)   proj = abm3pc_sys(         f = dBdt,         a = 0,          b = 1,         n = ecofit$internal$control$n_steps,         Pars = p,         type_i = type_i,         n_species = n_taxa,         F_type = \"integrated\",         y0 = State )   biomass1 = rev( proj$y[,match(taxon,ecofit$internal$taxa)] )[1]   return( biomass1 - biomass ) } # Calculate predicted and true curves x = seq(0, 2*K, length=1000)[-1] if(prod_func==\"Scaefer\") y = r * x * (1 - x/K) if(prod_func==\"Fox\") y = r * x * log(K/x) yhat = sapply( x, FUN=prod_fun, ecofit=out,                Xprime = out$internal$parhat$Xprime_ij,                 logPB = out$internal$parhat$logPB_i )  # Solve for Bmsy / B0 in production function dBdt_approx = function(b, x, p){   # dBdt for single autotroph (not annualized)   dBdt_expr = expression(b * p * (1-b) / (x - 1 + b))   # Solve for d/db dBdt = 0 as min_b((d/db dBdt)^2)   #eval( D(dBdt,\"b\") )^2   # OR:  -dBdt   eval(dBdt_expr) } phi1 = optimize( dBdt_approx, lower=0.01, upper=0.99, maximum=TRUE,                 x = 1+exp(out$internal$parhat[['Xprime_ij']][1,1]),                  p = exp(out$internal$parhat[['logPB_i']]) )$maximum # Empirical phi2 = x[which.max(yhat)] / 1000  # msy1 = exp(out$internal$parhat$logB_i) * dBdt_approx(phi1,                  x = 1+exp(out$internal$parhat[['Xprime_ij']][1,1]),                  p = exp(out$internal$parhat[['logPB_i']]) ) # msy2 = yhat[which.max(yhat)] #  true_msy = y[which.max(y)]  # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) lines( x=x, y=yhat, lwd=3, col=\"red\" )    # *exp(out$internal$parhat$logq_i) # Extract estimated biomass Bhat_t = out$derived$Est$B_ti Bse_t = out$derived$SE$B_ti  # Reformat to long-form data frame for ggplot results = cbind( \"Year\" = years,                  \"True\" = as.vector(B_t),                  \"Obs\" = as.vector(Bobs_t),                  \"Est\" = as.vector(Bhat_t),                  \"SE\" = as.vector(Bse_t) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True), colour=\"red\" ) +    geom_line( aes(x=as.numeric(Year), y=Obs) ) +    geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-1.96*SE, ymax=Est+1.96*SE), alpha=0.2)"},{"path":"/articles/surplus_production.html","id":"bivariate-production-model","dir":"Articles","previous_headings":"","what":"Bivariate production model","title":"EcoState as surplus production model","text":"Similarly, fit two-species production model data: can calculate visualize changes production function:","code":"# Inputs taxa = c( \"prey\", \"target\" ) n_taxa = length(taxa) PB_i = c( 5, 0.1 ) QB_i = c( NA, 0.5 ) DC_ij = matrix( c(0,0,1,0), nrow=2 ) X_ij = matrix( 2, nrow=2, ncol=2 ) U_i = c( 0.2, 0.2 ) type = c( \"auto\", \"hetero\" ) EE_i = c( 1, NA )  B_i = c( NA, 1 )  # Settings: specify what parameters to estimate fit_eps = \"target\"   # process errors fit_Q = \"target\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"target\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ) }  # Run model out_bivar = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 log_prior = log_prior,                 control = ecostate_control() )  # print output to terminal out_bivar #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 23.59865 secs #> Negative log-likelihood: -75.16433 #>  #> EcoSim parameters: #>          type  QB  PB         B EE   U #> prey     auto  NA 5.0  81.99584  1 0.2 #> target hetero 0.5 0.1 819.95841  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey target #>   prey      0      1 #>   target    0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey target #>   prey      2      2 #>   target    2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.7092536  0.0935837 #> logtau_i -2.6240934  0.2387366 #> logq_i    0.1161167  0.1428179 #> Maximum gradient component: 1.10751e-05 # Calculate annualized production function yhat_bivar = sapply( x, FUN=prod_fun, ecofit=out_bivar, taxon=\"target\",                Xprime = out_bivar$internal$parhat$Xprime_ij,                 logPB = out_bivar$internal$parhat$logPB_i )  # Empirical phi_bivar = x[which.max(yhat_bivar)] / 1000  msy_bivar = yhat_bivar[which.max(yhat_bivar)]   # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) matplot( x=x, y=cbind(yhat,yhat_bivar), lwd=3, col=c(\"red\",\"blue\"),           type=\"l\", add=TRUE )   legend( \"topright\", fill=c(\"black\",\"red\",\"blue\"),          legend=c(\"True\",\"1-species\",\"2-species\"), bty=\"n\")"},{"path":"/articles/surplus_production.html","id":"age-structured-model","dir":"Articles","previous_headings":"","what":"Age-structured model","title":"EcoState as surplus production model","text":"Additionally, fit model also tracking abundance, average weight, consumption age target species. including single stanza. allows us extract time-series average age average weight.  age-structured production model, mean age decreases increased fishing, mean weight increases due compensatory growth ratio forage predator increases.","code":"# Inputs taxa = c( \"prey\", \"target\" ) n_taxa = length(taxa) PB_i = c( 5, 0.1 ) QB_i = c( NA, 0.5 ) DC_ij = matrix( c(0,0,1,0), nrow=2 ) X_ij = matrix( 2, nrow=2, ncol=2 ) U_i = c( 0.2, 0.2 ) type = c( \"auto\", \"hetero\" ) EE_i = c( 1, NA )  B_i = c( NA, 1 )  # Settings: specify what parameters to estimate fit_eps = \"target\"   # process errors fit_Q = \"target\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"target\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = dnorm( p$logtau_i, mean=log(0.2), sd=1, log=TRUE ) }  # Run model out_stanzas = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control(),                 log_prior = log_prior,                 settings = stanza_settings( taxa = taxa,                                             stanza_groups = c(\"target\"=\"age_structured\"),                                             K = c(\"age_structured\" = 0.1),                                             Wmat = c(\"age_structured\" = (2/3)^3),                                             d = c(\"age_structured\" = 2/3),                                             Amax = c(\"target\" = 30),                                             SpawnX = c(\"age_structured\" = 2)                                            ))  # print output to terminal out_stanzas #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 26.69284 secs #> Negative log-likelihood: -71.35349 #>  #> EcoSim parameters: #>          type  QB  PB         B EE   U #> prey     auto  NA 5.0  104.2852  1 0.2 #> target hetero 0.5 0.1 1042.8523  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey target #>   prey      0      1 #>   target    0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey target #>   prey      2      2 #>   target    2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.9497148 0.02793407 #> logtau_i -3.1538949 0.50332833 #> logq_i   -0.1443941 0.04695328 #> Maximum gradient component: 0.0002864114  # meanage_t = meanweight_t = rep(NA, length(years)) for(t in seq_along(years)){   meanage_t[t] = weighted.mean( x = 1:30,                                 w = exp(out_stanzas$rep$Y_tzz_g2[[1]][t,,'log_NageS']) )   meanweight_t[t] = weighted.mean( x = out_stanzas$rep$Y_tzz_g2[[1]][t,,'WageS'],                                    w = exp(out_stanzas$rep$Y_tzz_g2[[1]][t,,'log_NageS']) ) } par( mfrow=c(2,1), mar=c(3,4,2,1) ) plot( x=years, y=meanage_t, lwd=2, type=\"l\", main=\"Mean age\" ) plot( x=years, y=meanweight_t, lwd=2, type=\"l\", main=\"Mean weight\" )"},{"path":"/articles/surplus_production.html","id":"multi-stanza-age-structured-production-model","dir":"Articles","previous_headings":"","what":"Multi-stanza age-structured production model","title":"EcoState as surplus production model","text":"Finally, fit model three variables, representing forage species two age-structured “stanzas” focal species. , specify identical diet varying bioenergetics size: model includes process-errors first-stage (eggs recruits, age-0 age-2) second stage (age-2 onward), although variance stage-1 collapses zero simulation replicate.","code":"# Inputs taxa = c( \"prey\", \"stage1\", \"stage2\" ) n_taxa = length(taxa) PB_i = c( 5, 1, 0.1 ) QB_i = c( NA, NA, 0.5 ) DC_ij = cbind( \"prey\"=c(0,0,0), \"stage1\"=c(1,0,0), \"stage2\"=c(1,0,0)  ) X_ij = matrix( 2, nrow=length(taxa), ncol=length(taxa) ) U_i = c( 0.2, 0.2, 0.2 ) type = c( \"auto\", \"hetero\", \"hetero\" ) EE_i = c( 1, NA, NA )  B_i = c( NA, NA, 1 )  # Settings: specify what parameters to estimate fit_eps = c(\"stage1\",\"stage2\")   # process errors fit_Q = \"stage2\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"stage2\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)  # Define priors log_prior = function(p){   # Prior on process-error log-SD to stabilize model   logp = sum(dnorm( p$logtau_i[2:3], mean=log(0.2), sd=1, log=TRUE)) }  # Run model out_trivar = ecostate(    taxa = taxa,   years = years,   catch = data.frame(\"Mass\"=Catch[,1],\"Year\"=Catch[,2],\"Taxon\"=\"stage2\"),   biomass = data.frame(\"Mass\"=Biomass[,1],\"Year\"=Biomass[,2],\"Taxon\"=\"stage2\"),   PB = PB_i,   QB = QB_i,   DC = DC_ij,   B = B_i,   EE = EE_i,   X = X_ij,   type = type,   U = U_i,   fit_B = fit_B,   fit_Q = fit_Q,   fit_eps = fit_eps,   fit_B0 = fit_B0,   log_prior = log_prior,   control = ecostate_control(),   settings = stanza_settings(      taxa = taxa,     stanza_groups = c(\"stage1\"=\"age_structured\", \"stage2\"=\"age_structured\"),     K = c(\"age_structured\" = 0.1),     Wmat = c(\"age_structured\" = (2/3)^3),     d = c(\"age_structured\" = 2/3),     Amax = c(\"stage1\" = 2, \"stage2\" = 30),     SpawnX = c(\"age_structured\" = 2) ) ) #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = list(obj$gr, #> : NA/NaN function evaluation  # print output to terminal out_trivar #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 1.288744 mins #> Negative log-likelihood: -70.41958 #>  #> EcoSim parameters: #>          type       QB  PB            B EE   U #> prey     auto       NA 5.0  106.7457516  1 0.2 #> stage1 hetero 3.916939 1.0    0.8281451  0 0.2 #> stage2 hetero 0.500000 0.1 1060.9699286  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     prey stage1 stage2 #>   prey      0      1      1 #>   stage1    0      0      0 #>   stage2    0      0      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey     prey stage1 stage2 #>   prey      2      2      2 #>   stage1    2      2      2 #>   stage2    2      2      2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> logB_i    6.9669388 0.08521457 #> logtau_i  0.3498846 0.37557231 #> logtau_i -3.1440545 0.50456842 #> logq_i   -0.1292594 0.09806604 #> Maximum gradient component: 1.809354e-09"},{"path":"/articles/surplus_production.html","id":"comparison-with-other-models","dir":"Articles","previous_headings":"","what":"Comparison with other models","title":"EcoState as surplus production model","text":"can compare state-space production model continuous time (SPiCT):  Similarly, can compare Just Another Bayesian Biomass Assessment (JABBA):  Comparing two shows SPICT, JABBA, configurations EcoState errors estimating population scale, presumably due mis-specifying production function. expected, age-structured 2-species EcoState models result identical estimates, age-structured version also provides auxiliary information changes average age size. Runtime vignette: 2.65 mins","code":"library(spict) #> Loading required package: TMB #>  #> Attaching package: 'TMB' #> The following objects are masked from 'package:RTMB': #>  #>     checkConsistency, MakeADFun, oneStepPredict, sdreport #> Welcome to spict_v1.3.8@107a32  # Format for SPiCT datalist = list(   obsC = C_t[-1],   timeC = years[-1],   obsI = Bobs_t,   timeI = years               )  # Fit and plot res <- fit.spict(datalist) plotspict.biomass(res) library(JABBA)  # Compile JABBA JAGS model and input object jbinput = build_jabba( catch = data.frame(Year=years, Total=C_t)[-1,],                        cpue = data.frame(Year=years, Index=Bobs_t)[-1,],                        se = data.frame(Year=years, Index=0.1)[-1,],                        assessment = \"target\",                        scenario = \"TestRun\",                        model.type = \"Schaefer\",                        sigma.est = FALSE,                        fixed.obsE = 0.1 ) #>  #> ><> Prepare JABBA input data <>< #>  #> ><> Assume Catch with error CV = 0.1 <>< #>  #> ><> Model type:Schaefer <>< #>  #> ><> Shape m =2 #>  #> ><> K prior mean =888.164844109276and CV =1(log.sd = 0.832554611157698) #>  #> ><> r prior mean =0.2and CV =0.532940350027788(log.sd = 0.5) #>  #> ><> Psi (B1/K) prior mean =0.9and CV =0.25withlnormdestribution #>  #>  #>  #> ><> ALWAYS ENSURE to adjust default settings to your specific stock <><  # Fit JABBA (here mostly default value - careful) bet1 = fit_jabba(jbinput, quickmcmc=TRUE) #> module glm loaded #> Compiling model graph #>    Resolving undeclared variables #>    Allocating nodes #> Graph information: #>    Observed stochastic nodes: 120 #>    Unobserved stochastic nodes: 124 #>    Total graph size: 2169 #>  #> Initializing model #>  #> ><> Produce results output of Schaefer model for target TestRun <>< #>  #>  #> ><> Scenario TestRun_Schaefer completed in 0 min and 13 sec <><  # Make individual plots jbplot_cpuefits(bet1) #>  #> ><> jbplot_cpue() - fits to CPUE <>< # Compare estimates knitr::kable(rbind(   \"True\" = c(\"q\" = q, \"K\"=K, \"MSY\"=true_msy),   \"EcoState 1-species\" = c(exp(out$opt$par[c('logq_i','logB_i')]),msy2),   \"EcoState 2-species\" = c(exp(out_bivar$opt$par[c('logq_i','logB_i')]),msy_bivar),   \"EcoState age-structured\" = c(exp(out_stanzas$opt$par[c('logq_i','logB_i')]),NA),   \"EcoState multi-stanza\" = c(exp(out_trivar$opt$par[c('logq_i','logB_i')]),NA),   \"SPiCT\" = c(res$value[c('q','K','MSY')]),   \"JABBA\" = c(bet1$pars[c('q','K'),'Median'],bet1$estimates['MSY','mu']) ), digits=3)"},{"path":"/articles/web_only/whole_of_ecosystem.html","id":"eastern-bering-sea","dir":"Articles > Web_only","previous_headings":"","what":"Eastern Bering Sea","title":"Whole of ecosystem model","text":"first load various inputs used Rpath: also load time-series surveys catches used MICE model demonstration: reformat various Rpath inputs. particular, eliminate pelagic detritus pool (EcoState currently allow one detritus functional group), add benthic_detritus Ecopath inputs (Ecopath solves equilibrium values detritus jointly groups): specify parameters estimate: Finally, build inputs without running model, modify TMB map manually, estimate parameters can compare equilibrium biomass packages. identical many taxa () specify values biomass many taxa, also differ arrowtooth cod estimating equilibrium biomass two taxa: Runtime vignette: 21.33 mins","code":"data( whitehouse_2021 ) Ecopath = whitehouse_2021$Ecopath Diet = whitehouse_2021$Diet stanzas = whitehouse_2021$stanzas stanza_groups = whitehouse_2021$stanza_groups data( eastern_bering_sea ) Catch = eastern_bering_sea$Catch catch = data.frame( \"Year\"=Catch$Year, \"Mass\"=Catch$Mass, \"Taxon\"=Catch$Taxon ) catch$Taxon = sapply( catch$Taxon, FUN=switch, \"Arrowtooth\" = \"Arrowtooth flounder adult\",                                                \"Cod\" = \"Pacific cod adult\",                                                \"Pollock\" = \"Walleye pollock adult\" )  # Fish = eastern_bering_sea$Survey biomass = data.frame(   \"Mass\" = Fish$Mass,   \"Year\" = Fish$Year,   \"Taxon\" = sapply( Fish$Taxon, FUN=switch, \"Arrowtooth\" = \"Arrowtooth flounder adult\",                                               \"Cod\" = \"Pacific cod adult\",                                               \"Pollock\" = \"Walleye pollock adult\",                                               NA) ) biomass = na.omit(biomass) # which_ecopath = setdiff(1:nrow(Ecopath), 66) taxa = c( Ecopath[which_ecopath,'Functional.group'], \"benthic_detritus\" ) type = sapply( taxa, FUN = switch,                       \"benthic_detritus\" = \"detritus\",                       \"Large phytoplankton\" = \"auto\",                       \"Small phytoplankton\" = \"auto\",                       \"hetero\" ) PB = c( Ecopath[which_ecopath,'P.B'], 0.5 ) QB = c( Ecopath[which_ecopath,'Q.B'], NA ) B = c( Ecopath[which_ecopath,'Biomass'], NA ) EE = c( Ecopath[which_ecopath,'EE'], 0.5 ) U = c( rep(0.2,length(which_ecopath)), 0 )  # Modify EE EE = ifelse( taxa %in% c(\"benthic_detritus\",\"Walleye pollock adult\"), EE, NA )  #  which_cols = which_ecopath + 1 which_rows = c( which_ecopath, 72 ) DC = cbind( Diet[which_rows, which_cols], \"benthic_detritus\"=0 ) DC = ifelse( is.na(DC), 0, as.matrix(DC) ) X = array(2, dim=rep(length(taxa),2) )  # stgroups = stanza_groups[,'StanzaGroup'][stanzas[,'StGroupNum']] Amax = ceiling((stanzas[,'Last']+1) / 12)  # K = stanza_groups[,'VBGF_Ksp'] d = stanza_groups[,'VBGF_d'] Wmat = stanza_groups[,'Wmat'] SpawnX = rep(2, length(K))  # Add names names(PB) = names(QB) = names(B) = names(EE) = names(U) = names(type) = taxa dimnames(DC) = dimnames(X) = list( taxa, taxa ) names(Amax) = names(stgroups) = taxa[stanzas[,'GroupNum']] names(K) = names(d) = names(Wmat) = names(SpawnX) = unique(stgroups)  # Eliminate juvenile values which_juv = stanzas[which(!stanzas[,'Leading']),'GroupNum'] QB[which_juv] = B[which_juv] = NA # Fit catchability coefficient for adult pollock fit_Q = c( \"Walleye pollock adult\" )  # fit equilibrium biomass for adult arrowtooth and cod fit_B = c( \"Arrowtooth flounder adult\", \"Pacific cod adult\" ) run = function( map, nlminb_loops, getsd ){   out = ecostate(     taxa = taxa,     years = 1981:2020,     catch = catch,     biomass = biomass,     PB = PB,     QB = QB,     DC = DC,     B = B,     EE = EE,     X = X,     type = type,     U = U,     fit_B = fit_B,     fit_Q = fit_Q,     control = ecostate_control( nlminb_loops = nlminb_loops,                                 getsd = getsd,                                 n_steps = 30,                                 profile = NULL,                                 random = NULL,                                 map = map,                                 start_tau = 0.1 ),     settings = stanza_settings(       taxa = taxa,       stanza_groups = stgroups,       K = K,       Wmat = Wmat,       d = d,       Amax = Amax,       SpawnX = SpawnX,       STEPS_PER_YEAR = 12 )   ) } out0 = run( map = NULL,            nlminb_loops = 0,            getsd = FALSE ) map = out0$tmb_inputs$map   map$logtau_i = factor(rep(NA,length(map$logtau_i))) out = run( map = map,            nlminb_loops = 1,            getsd = TRUE ) # runtime out$run_time #> Time difference of 20.38786 mins  # Compile stuff Borig = c( Ecopath[which_ecopath,'Biomass'], NA ) Bhat = print_ecopars(out, silent=TRUE)[[1]][,'B'] df = data.frame( taxa,                   \"Whitehouse\" = Borig,                   \"EcoState\" = Bhat,                   \"Difference\" = Bhat - Borig ) knitr::kable( df, digits=3 )"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James T. Thorson. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. EcoState:  Extending Ecopath Ecosim estimate biological parameters process errors using RTMB time-series data","code":"@Article{,   title = {EcoState:  Extending Ecopath with Ecosim to estimate biological parameters and process errors using RTMB and time-series data},   journal = {In review},   year = {2024},   url = {https://doi.org/10.32942/X2QK81},   author = {J. T. Thorson and K. Kristensen and K. Aydin and S. Gaichas and D. G. Kimmel and E. A. McHuron and J. N. Nielsen and H. Townsend and G. A. Whitehouse}, }"},{"path":"/index.html","id":"ecostate","dir":"","previous_headings":"","what":"State-Space Extension of EcoPath with EcoSim","title":"State-Space Extension of EcoPath with EcoSim","text":"Package ecostate fits state-space mass-balance model EcoState intended aquatic ecosystems, using mass-balance equations matching Ecopath dynamical equations matching Ecosim. Unlike Ecopath--Ecosim (EwE) package, ecostate fits biological parameters (e.g., equilibrium biomass predator-prey vulnerability) measurement parameters (e.g., catchability coefficients) via fit time-series data. ecostate also estimates additional process errors representing nonstationarity growth efficiency, ecotrophic efficient, migration, unmodeled processes. process errors allow biomass patterns closely match available data, resulting consumption (associated productivity mortality rates) can accurately conditioned upon residual patterns.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"State-Space Extension of EcoPath with EcoSim","text":"ecostate can installed GitHub using: access vignettes R session, please instead use:","code":"library(remotes) install_github( \"James-Thorson-NOAA/ecostate\" ) remotes::install_github( \"James-Thorson-NOAA/ecostate\",                           build_vignettes = TRUE ) browseVignettes(\"ecostate\")"},{"path":"/index.html","id":"more-details","dir":"","previous_headings":"","what":"More details","title":"State-Space Extension of EcoPath with EcoSim","text":"background please read: Thorson, J. Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. EcoState: Extending Ecopath Ecosim estimate biological parameters process errors using RTMB time-series data. Pre-print URL: https://doi.org/10.32942/X2QK81 updated version: Thorson, J. Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. (press) benefits hierarchical ecosystem models: demonstration using new state-space mass-balance model EcoState. Fish Fisheries.","code":""},{"path":"/reference/abm3pc_sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"Third-order Adams-Bashford-Moulton predictor-corrector method.","code":""},{"path":"/reference/abm3pc_sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"","code":"abm3pc_sys(f, a, b, y0, n, Pars, ...)"},{"path":"/reference/abm3pc_sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n number steps Pars named list parameters passed f ... additional inputs function f","code":""},{"path":"/reference/abm3pc_sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"Combined Adams-Bashford Adams-Moulton (: multi-step) method third order corrections according predictor-corrector approach. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/add_equilibrium.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute equilibrium values — add_equilibrium","title":"Compute equilibrium values — add_equilibrium","text":"Compute equilibrium values","code":""},{"path":"/reference/add_equilibrium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute equilibrium values — add_equilibrium","text":"","code":"add_equilibrium(ecoparams, scale_solver, noB_i, type_i)"},{"path":"/reference/add_equilibrium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute equilibrium values — add_equilibrium","text":"ecoparams list parameters scale_solver Whether solve ecotrophic efficiency EE given biomass B (scale_solver=\"simple\") solve combination EE B values noB_i Boolean vector indicating taxa B value type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\"","code":""},{"path":"/reference/add_equilibrium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute equilibrium values — add_equilibrium","text":"Replaces NA values ecotrophic efficiency /biomass equilibrium solution, calculates equilibrium consumption, natural mortality, rates.","code":""},{"path":"/reference/compute_nll.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute negative log-likelihood for EcoState model — compute_nll","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"Compute negative log-likelihood EcoState model","code":""},{"path":"/reference/compute_nll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"","code":"compute_nll(   p,   taxa,   years,   noB_i,   type_i,   n_species,   project_vars,   DC_ij,   Bobs_ti,   Cobs_ti,   Nobs_ta_g2,   Wobs_ta_g2,   log_prior,   fit_eps,   fit_nu,   stanza_data,   settings,   control )"},{"path":"/reference/compute_nll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"p list parameters taxa Character vector taxa included model. years Integer-vector years included model noB_i Boolean vector indicating taxa B value type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" n_species number species project_vars function integrate differential equation DC_ij Diet projections matrix Bobs_ti formatted matrix biomass data Cobs_ti formatted matrix catch data Nobs_ta_g2 formatted list age-comp data Wobs_ta_g2 formatted list weight--age data log_prior user-provided function takes input list parameters $obj$env$parList() output ecostate(), returns numeric vector sum log-prior probability.  example log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE) specifies lognormal prior probability catchability coefficient first taxa logmean zero logsd 0.1 fit_eps Character-vector listing taxa model estimate annual process errors dB/dt fit_nu Character-vector listing taxa model estimate annual process errors consumption Q_ij stanza_data output make_stanza_data settings Output stanza_settings(), used define age-structured dynamics (called stanza-groups). control output ecostate_control","code":""},{"path":"/reference/compute_nll.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"Given list parameters, calculates joint negative log-likelihood, Laplace approximation used marginalize across random effects calculate log-marginal likelihood fixed effects. joint likelihood includes fit fishery catches, biomass indices, age-composition data, weight--age data, priors, distribution random effects.","code":""},{"path":"/reference/compute_tracer.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tracers, e.g., trophic level — compute_tracer","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Calculate tracer propagates consumption.","code":""},{"path":"/reference/compute_tracer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"","code":"compute_tracer(   Q_ij,   inverse_method = c(\"Penrose_moore\", \"Standard\"),   type_i,   tracer_i = rep(1, nrow(Q_ij)) )"},{"path":"/reference/compute_tracer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Q_ij Consumption prey predator j units biomass. inverse_method whether use pseudoinverse standard inverse type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" tracer_i indicator matrix specifying traver value","code":""},{"path":"/reference/compute_tracer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Trophic level \\(y_i\\) predator \\(\\) defined : $$ \\mathbf{y = l Q^* + 1} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level. generically, tracer might used track movement biomass consumption.  example, tracer \\(x_i\\) 1 base pelagic food chain, 0 otherwise, can calculate proportion pelagic vs. nonpelagic biomass taxon: $$ \\mathbf{y = l Q^* + x} $$ allows us separate alternative components foodweb.","code":""},{"path":"/reference/dBdt.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamics from EcoSim — dBdt","title":"Dynamics from EcoSim — dBdt","text":"Compute system differential equations representing EcoState dynamics derived EcoSim.","code":""},{"path":"/reference/dBdt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamics from EcoSim — dBdt","text":"","code":"dBdt(   Time,   State,   Pars,   type_i,   n_species,   F_type = \"integrated\",   what = \"dBdt\" )"},{"path":"/reference/dBdt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamics from EcoSim — dBdt","text":"Time used State vector state variables integrate Pars list parameters governing ODE type_i type taxon n_species number species F_type whether integrate catches along biomass (\"integrated\") calculate catches Baranov catch equation applied average biomass (\"averaged\") output produce","code":""},{"path":"/reference/dBdt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamics from EcoSim — dBdt","text":"object (list) ranges. Elements include: G_i Biomass growth per time g_i Biomass growth per time per biomass M2_i Consumptive mortality per time m2_i Consumptive mortality per time per biomass M_i Natural mortality per time m_i Natural mortality per time per biomass (.e., m2_i + m0_i) Q_ij Consumption per time prey (rows) predator (columns)","code":""},{"path":"/reference/dBdt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dynamics from EcoSim — dBdt","text":"function syntax designed match pracma solvers.","code":""},{"path":"/reference/ddirmult.html","id":null,"dir":"Reference","previous_headings":"","what":"Dirichlet-multinomial — ddirmult","title":"Dirichlet-multinomial — ddirmult","text":"Allows data-weighting parameter","code":""},{"path":"/reference/ddirmult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dirichlet-multinomial — ddirmult","text":"","code":"ddirmult(x, prob, ln_theta, log = TRUE)"},{"path":"/reference/ddirmult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dirichlet-multinomial — ddirmult","text":"x numeric vector observations across categories prob numeric vector category probabilities ln_theta logit-ratio effective input sample size log whether return log-probability ","code":""},{"path":"/reference/ddirmult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dirichlet-multinomial — ddirmult","text":"","code":"library(RTMB) prob = rep(0.1,10) x = rmultinom( n=1, prob=prob, size=20 )[,1] f = function( ln_theta ) ddirmult(x, prob, ln_theta) f( 0 ) #> [1] -15.26349 F = MakeTape(f, 0) F$jacfun()(0) #>          [,1] #> [1,] 0.850599"},{"path":"/reference/eastern_bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"eastern Bering Sea ecosystem data — eastern_bering_sea","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"Data used demonstrate Model Intermediate Complexity (MICE) eastern Bering Sea. data(eastern_bering_sea) loads list includes four components: Survey long-form data-frame three columns, providing Year, Mass (relative units taxa, million metric tons Pollock, Cod, Arrowtooth, NFS), Taxon year available data Catch long-form data-frame three columns, providing Year, Mass (million metric tons), Taxon year available data P_over_B numeric vector unitless ratio biomass production population biomass taxon Q_over_B numeric vector unitless ratio biomass consumption population biomass taxon Diet_proportions numeric matrix column lists proportion biomass consumed provided prey (row)","code":""},{"path":"/reference/eastern_bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"","code":"data(eastern_bering_sea)"},{"path":"/reference/eastern_bering_sea.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"data compiled come variety sources: Northern fur seal (NFS) survey absolute index, corrected proportion time spent eastern Bering Sea.  NFS QB developed bioenergetic model also corrected seasonal residency. provided Elizabeth McHuron. post-processed variety ways, treated index abundance NFS uses. Pollock, cod, arrowtooth surveys bottom trawl survey, cod arrowtooth treated absolute index. Copepod zooplankton oblique tow bongo net survey, data provided Dave Kimmel.  post-processed account spatially seaonally imbalanced data. P_over_B, Q_over_B Diet_proportions values derived Rpath models, provided Andy Whitehouse. Primary producers annual index relative biomass, developed monthly satellite measurements provided Jens Nielsen. See Thorson et al. (review) details regarding data standardization sources","code":""},{"path":"/reference/ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"fit EcoState model — ecostate","title":"fit EcoState model — ecostate","text":"Estimate parameters EcoState model","code":""},{"path":"/reference/ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fit EcoState model — ecostate","text":"","code":"ecostate(   taxa,   years,   catch = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),   biomass = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),   agecomp = list(),   weight = list(),   PB,   QB,   B,   DC,   EE,   X,   type,   U,   fit_B = vector(),   fit_Q = vector(),   fit_B0 = vector(),   fit_EE = vector(),   fit_PB = vector(),   fit_QB = vector(),   fit_eps = vector(),   fit_nu = vector(),   log_prior = function(p) 0,   settings = stanza_settings(taxa = taxa),   control = ecostate_control() )"},{"path":"/reference/ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fit EcoState model — ecostate","text":"taxa Character vector taxa included model. years Integer-vector years included model catch long-form data frame columns Mass, Year  Taxon biomass long-form data frame columns Mass, Year  Taxon, Mass assumed units catch agecomp named list, names corresponding stanza_groups, list-element matrix rownames years colnames integer ages, NA excludes entry inclusion model computes likelihood across included ages given year, rowsum input-sample size given year weight named list, names corresponding stanza_groups, list-element matrix rownames years colnames integer ages, NA excludes entry inclusion model computes lognormal likelihood weight--age specified age-year combination PB numeric-vector names matching taxa, providing ratio production biomass taxon QB numeric-vector names matching taxa, providing ratio consumption biomass taxon B numeric-vector names matching taxa, providing starting (fixed) value equilibrium biomass taxon DC numeric-matrix rownames colnames matching taxa, column provides diet proportion given predator EE numeric-vector names matching taxa, providing proportion proportion production subsequently modeled (termed ecotrophic efficiency) X numeric-matrix rownames colnames matching taxa, element gives vulnerability parameter given interaction. type character-vector names matching taxa elements c(\"auto\",\"hetero\",\"detritus\"), indicating whether taxon primary producer, consumer/predator, detritus, respectively. U numeric-vector names matching taxa, providing proportion consumption unassimilated therefore exported detritus fit_B Character-vector listing taxa equilibrium biomass estimated fixed effect fit_Q Character-vector listing taxa catchability coefficient estimated fixed effect fit_B0 Character-vector listing taxa ratio initial equilibrium biomass estimated fixed effect fit_EE Character-vector listing taxa ecotrophic efficiency estimated. fit_PB Character-vector listing taxa equilibrium production per biomass estimated.  Note likely good idea include prior species estimated. fit_QB Character-vector listing taxa equilibrium consumption per biomass estimated.  Note likely good idea include prior species estimated. fit_eps Character-vector listing taxa model estimate annual process errors dB/dt fit_nu Character-vector listing taxa model estimate annual process errors consumption Q_ij log_prior user-provided function takes input list parameters $obj$env$parList() output ecostate(), returns numeric vector sum log-prior probability.  example log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE) specifies lognormal prior probability catchability coefficient first taxa logmean zero logsd 0.1 settings Output stanza_settings(), used define age-structured dynamics (called stanza-groups). control Output ecostate_control(), used define user settings.","code":""},{"path":"/reference/ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"fit EcoState model — ecostate","text":"object (list) S3-class ecostate. Elements include: obj RTMB object MakeADFun tmb_inputs list inputs passed MakeADFun opt output nlminb sdrep output sdreport interal Objects useful package function, .e., arguments passed call rep report file, including matrix B_ti biomass year t taxon , g_ti growth rate per biomass, see dBdt quantities reported year derived derived quantity estimates standard errors, rep objects requested call function call record run_time Total runtime S3 class functions summary, print, logLik","code":""},{"path":"/reference/ecostate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fit EcoState model — ecostate","text":"taxa must included QB, PB, B, DC, additional taxa can QB, PB, B, DC taxa.  taxa can used redefine set modeled species without changing inputs","code":""},{"path":"/reference/ecostate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"fit EcoState model — ecostate","text":"Introducing state-space mass-balance model: Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.(press). benefits hierarchical ecosystem models: demonstration using new state-space mass-balance model EcoState. Fish Fisheries.","code":""},{"path":"/reference/ecostate_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for ecostate structure — ecostate_control","title":"Detailed control for ecostate structure — ecostate_control","text":"Define list control parameters.","code":""},{"path":"/reference/ecostate_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for ecostate structure — ecostate_control","text":"","code":"ecostate_control(   nlminb_loops = 1,   newton_loops = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   silent = getOption(\"ecostate.silent\", TRUE),   trace = getOption(\"ecostate.trace\", 0),   verbose = getOption(\"ecostate.verbose\", FALSE),   profile = c(\"logF_ti\", \"log_winf_z\", \"s50_z\", \"srate_z\"),   random = c(\"epsilon_ti\", \"alpha_ti\", \"nu_ti\", \"phi_tg2\"),   tmb_par = NULL,   map = NULL,   getJointPrecision = FALSE,   integration_method = c(\"ABM\", \"RK4\", \"ode23\", \"rk4\", \"lsoda\"),   process_error = c(\"epsilon\", \"alpha\"),   n_steps = 10,   F_type = c(\"integrated\", \"averaged\"),   derived_quantities = c(\"h_g2\", \"B_ti\", \"B0_i\"),   scale_solver = c(\"joint\", \"simple\"),   inverse_method = c(\"Standard\", \"Penrose_moore\"),   tmbad.sparse_hessian_compress = 1,   start_tau = 0.001 )"},{"path":"/reference/ecostate_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for ecostate structure — ecostate_control","text":"nlminb_loops Integer number times call stats::nlminb(). newton_loops Integer number Newton steps running stats::nlminb(). eval.max Maximum number evaluations objective function allowed. Passed control stats::nlminb(). iter.max Maximum number iterations allowed. Passed control stats::nlminb(). getsd Boolean indicating whether call TMB::sdreport() silent Disable terminal output inner optimizer? trace Parameter values printed every trace iteration outer optimizer. Passed control stats::nlminb(). verbose Output additional messages model steps fitting? profile parameters profiled across, passed MakeADFun random parameters treated random effects, passed MakeADFun tmb_par list parameters starting values, shape identical tinyVAST(...)$internal$parlist map list mapping values, passed RTMB::MakeADFun getJointPrecision whether get joint precision matrix.  Passed sdreport. integration_method numerical integration method use. \"ABM\" uses native-R versions Adam-Bashford, \"RK4\" uses native-R version Runge-Kutta-4, \"ode23\" uses native-R version adaptive Runge-Kutta-23, adapted pracma functions. \"rk4\" lsoda use methods deSolve::ode implemented RTMBode::ode process_error Whether include process error continuous rate (.e., \"innovation\" parameterization, process_error=\"epsilon\") discrete difference expected predicted biomass (.e., \"state-space\" parameterization), process_error=\"alpha\"former interpretable, whereas latter much computationally efficient. n_steps number steps used ODE solver biomass dynamics F_type whether integrate catches along biomass (\"integrated\") calculate catches Baranov catch equation applied average biomass (\"averaged\") derived_quantities character-vector listing objects ADREPORT scale_solver Whether solve ecotrophic efficiency EE given biomass B (scale_solver=\"simple\") solve combination EE B values inverse_method whether use pseudoinverse standard inverse tmbad.sparse_hessian_compress passed TMB::config(), enabling experimental feature save memory first computing inner Hessian matrix.  Using tmbad.sparse_hessian_compress=1 seems effect MLE (although users probably confirm ), hugely reduces memory use small large models. Using tmbad.sparse_hessian_compress=1 seems hugely speed model-fitting large model results small decrease speed model-fitting small model. start_tau Starting value standard deviation process errors","code":""},{"path":"/reference/ginv.html","id":null,"dir":"Reference","previous_headings":"","what":"Penrose-Moore pseudoinverse — ginv","title":"Penrose-Moore pseudoinverse — ginv","text":"Extend MASS:ginv work RTMB","code":""},{"path":"/reference/ginv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penrose-Moore pseudoinverse — ginv","text":"","code":"ginv(x)"},{"path":"/reference/ginv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penrose-Moore pseudoinverse — ginv","text":"x Matrix used compute pseudoinverse","code":""},{"path":"/reference/logLik.ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal log-likelihood — logLik.ecostate","title":"Marginal log-likelihood — logLik.ecostate","text":"Extract (marginal) log-likelihood ecostate model","code":""},{"path":"/reference/logLik.ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal log-likelihood — logLik.ecostate","text":"","code":"# S3 method for class 'ecostate' logLik(object, ...)"},{"path":"/reference/logLik.ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal log-likelihood — logLik.ecostate","text":"object Output ecostate ... used","code":""},{"path":"/reference/logLik.ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal log-likelihood — logLik.ecostate","text":"object class logLik attributes val log-likelihood df number parameters Returns object class logLik. attributes \"df\" (degrees freedom) giving number (estimated) fixed effects model, abd \"val\" (value) giving marginal log-likelihood. class allows AIC work expected.","code":""},{"path":"/reference/ode23.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-stiff (and stiff) ODE solvers — ode23","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"Runge-Kutta (2, 3)-method variable step size, resp","code":""},{"path":"/reference/ode23.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"","code":"ode23(f, a, b, y0, n, Pars, rtol = 0.001, atol = 1e-06)"},{"path":"/reference/ode23.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n used Pars named list parameters passed f rtol relative tolerance. atol absolute tolerance.","code":""},{"path":"/reference/ode23.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"Copied pracma GPL-3, small modifications work RTMB. can used simulate dynamics, estimation","code":""},{"path":"/reference/plot_foodweb.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot foodweb — plot_foodweb","title":"Plot foodweb — plot_foodweb","text":"Plot consumption directed graph including taxa (vertices) biomass consumed (arrows).  Taxa located using tracers, default y-axis trophic level.  #'","code":""},{"path":"/reference/plot_foodweb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot foodweb — plot_foodweb","text":"","code":"plot_foodweb(   Q_ij,   type_i,   xtracer_i,   ytracer_i = rep(1, nrow(Q_ij)),   B_i = rep(1, nrow(Q_ij)),   taxa_labels = letters[1:nrow(Q_ij)],   xloc,   yloc )"},{"path":"/reference/plot_foodweb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot foodweb — plot_foodweb","text":"Q_ij Consumption prey predator j units biomass. type_i character vector indicating whether taxon \"hetero\", \"auto\", \"detritus\" xtracer_i tracer use computing x-axis values ytracer_i tracer use computing y-axis values B_i biomass use weighting taxa plot taxa_labels character vector labels use taxon xloc x-axis location (overrides calculation using xtracer_i) yloc y-axis location (overrides calculation using ytracer_i)","code":""},{"path":"/reference/plot_foodweb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot foodweb — plot_foodweb","text":"Trophic level \\(l_i\\) predator \\(\\) defined : $$ \\mathbf{l - 1 = l Q^*} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level.","code":""},{"path":"/reference/print.ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitted ecostate object — print.ecostate","title":"Print fitted ecostate object — print.ecostate","text":"Prints output fitted ecostate model","code":""},{"path":"/reference/print.ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitted ecostate object — print.ecostate","text":"","code":"# S3 method for class 'ecostate' print(x, ...)"},{"path":"/reference/print.ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitted ecostate object — print.ecostate","text":"x Output ecostate ... used","code":""},{"path":"/reference/print.ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print fitted ecostate object — print.ecostate","text":"return value, called provide clean terminal output calling fitted object terminal.","code":""},{"path":"/reference/print_ecopars.html","id":null,"dir":"Reference","previous_headings":"","what":"Print EcoSim parameters — print_ecopars","title":"Print EcoSim parameters — print_ecopars","text":"Prints parameters defining EcoSim dynamics","code":""},{"path":"/reference/print_ecopars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print EcoSim parameters — print_ecopars","text":"","code":"print_ecopars(x, silent = FALSE)"},{"path":"/reference/print_ecopars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print EcoSim parameters — print_ecopars","text":"x Output ecostate silent whether print terminal","code":""},{"path":"/reference/print_ecopars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print EcoSim parameters — print_ecopars","text":"invisibly returns table printed","code":""},{"path":"/reference/rk4sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Classical Runge-Kutta for system of equations — rk4sys","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"Classical Runge-Kutta order 4.","code":""},{"path":"/reference/rk4sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"","code":"rk4sys(f, a, b, y0, n, Pars, ...)"},{"path":"/reference/rk4sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n number steps b. Pars named list parameters passed f ... additional inputs function f","code":""},{"path":"/reference/rk4sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"Classical Runge-Kutta order 4 (systems ) ordinary differential equations fixed step size. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/stanza_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for stanza structure — stanza_settings","title":"Detailed control for stanza structure — stanza_settings","text":"Define list control parameters.","code":""},{"path":"/reference/stanza_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for stanza structure — stanza_settings","text":"","code":"stanza_settings(   taxa,   stanza_groups,   K,   d,   Wmat,   Amax,   SpawnX,   Leading,   fit_K = c(),   fit_d = c(),   fit_phi = vector(),   Amat = NULL,   Wmatslope,   STEPS_PER_YEAR = 1,   comp_weight = c(\"multinom\", \"dir\", \"dirmult\") )"},{"path":"/reference/stanza_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for stanza structure — stanza_settings","text":"taxa Character vector taxa included model. stanza_groups character-vector names corresponding taxa elements specifying multi-stanza group (.e., age-structured population) given taxa K numeric-vector names matching unique(stanza_groups), providing von Bertalanffy growth coefficient length d numeric-vector names matching unique(stanza_groups), providing von Bertalanffy allometric consumption--weight (default 2/3) Wmat numeric-vector names matching unique(stanza_groups), providing weight--maturity relative asymptotic weight Amax numeric-vector names matching names(stanza_groups), providing maximum age  (units years) given taxon (oldest taxon given stanza_group treated plus-group) SpawnX numeric-vector names matching unique(stanza_groups), providing larval vulnerability (density dependence) parameter Leading Boolean vector names matching names(stanza_groups), TRUE taxon scale (B EE) specified estimated, calculated determinstically taxa given stanza_group fit_K Character-vector listing stanza_groups K estimated fit_d Character-vector listing stanza_groups d estimated (note currently work) fit_phi Character-vector listing stanza_groups model estimate annual recruitment deviations, representing nonconsumptive variation larval survival (e.g., oceanographic advection) Amat numeric-vector names matching unique(stanza_groups), providing integer age--maturity (units years) Wmatslope numeric-vector names matching unique(stanza_groups), providing slope 0.5 maturity logistic maturity--weight ogive STEPS_PER_YEAR integer number Euler steps per year calculating integrating individual weight--age comp_weight method used weighting age-composition data","code":""},{"path":"/reference/stanza_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detailed control for stanza structure — stanza_settings","text":"object (list) S3-class stanza_settings.","code":""},{"path":"/reference/whitehouse_2021.html","id":null,"dir":"Reference","previous_headings":"","what":"Full rpath inputs for eastern Bering Sea — whitehouse_2021","title":"Full rpath inputs for eastern Bering Sea — whitehouse_2021","text":"Rpath inputs Whitehouse et al. 2021","code":""},{"path":"/reference/whitehouse_2021.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full rpath inputs for eastern Bering Sea — whitehouse_2021","text":"","code":"data(whitehouse_2021)"},{"path":"/news/index.html","id":"ecostate-010","dir":"Changelog","previous_headings":"","what":"EcoState 0.1.0","title":"EcoState 0.1.0","text":"Initial public release","code":""}]
